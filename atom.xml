<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrBird</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrbird.cc/"/>
  <updated>2019-07-12T13:02:30.454Z</updated>
  <id>http://mrbird.cc/</id>
  
  <author>
    <name>MrBird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Fork/Join使用学习</title>
    <link href="http://mrbird.cc/JDK7-Fork-Join.html"/>
    <id>http://mrbird.cc/JDK7-Fork-Join.html</id>
    <published>2019-03-21T03:20:14.000Z</published>
    <updated>2019-07-12T13:02:30.454Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>JDK7提供了一个将任务“分而治之”的框架 — Fork/Join。它把一个大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。分割的子任务分别放到双端队列里，然后启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。<a id="more"></a></p><p>Fork/Join的思想如下所示： <img src="img/QQ截图20190702172347.png" alt="QQ截图20190702172347.png"></p><h2 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a>RecursiveTask</h2><p><img src="img/QQ截图20190703111904.png" alt="QQ截图20190703111904.png"></p><p>RecursiveTask适用于将任务分而治之，并且有返回值的情况，举个计算1到100和的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小区间为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future = forkJoinPool.submit(<span class="keyword">new</span> CalculateRecursiveTask(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result = future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 起始</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CalculateRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果起始和结束范围小于我们定义的区间范围，则直接计算</span></span><br><span class="line">            <span class="keyword">if</span> ((end - start) &lt;= MAX_THRESHOLD) &#123;</span><br><span class="line">                <span class="keyword">return</span> IntStream.rangeClosed(start, end).sum();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，将范围一分为二，分成两个子任务</span></span><br><span class="line">                <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">                CalculateRecursiveTask leftTask = <span class="keyword">new</span> CalculateRecursiveTask(start, middle);</span><br><span class="line">                CalculateRecursiveTask rightTask = <span class="keyword">new</span> CalculateRecursiveTask(middle + <span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">// 执行子任务</span></span><br><span class="line">                leftTask.fork();</span><br><span class="line">                rightTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 汇总子任务</span></span><br><span class="line">                <span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ForkJoinPool使用submit或invoke提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。</p><p>启动程序输出如下：</p><p><img src="img/QQ截图20190703112347.png" alt="QQ截图20190703112347.png"></p><p>其实这里执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行子任务</span></span><br><span class="line"><span class="comment">// leftTask.fork();</span></span><br><span class="line"><span class="comment">// rightTask.fork();</span></span><br><span class="line">invokeAll(leftTask,rightTask);</span><br><span class="line"><span class="comment">// 汇总子任务</span></span><br><span class="line"><span class="keyword">return</span> leftTask.join() + rightTask.join();</span><br></pre></td></tr></table></figure><p></p><h2 id="RecursiveAction"><a href="#RecursiveAction" class="headerlink" title="RecursiveAction"></a>RecursiveAction</h2><p><img src="img/QQ截图20190703114411.png" alt="QQ截图20190703114411.png"></p><p>使用方式和RecursiveTask类似，只不过没有返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveActionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义最小区间为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRESHOLD = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicInteger SUM = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.submit(<span class="keyword">new</span> CalculateRecursiveAction(<span class="number">0</span>, <span class="number">100</span>));</span><br><span class="line">        forkJoinPool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(SUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateRecursiveAction</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 起始</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CalculateRecursiveAction</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果起始和结束范围小于我们定义的区间范围，则直接计算</span></span><br><span class="line">            <span class="keyword">if</span> ((end - start) &lt;= MAX_THRESHOLD) &#123;</span><br><span class="line">                SUM.addAndGet(IntStream.rangeClosed(start, end).sum());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，将范围一分为二，分成两个子任务</span></span><br><span class="line">                <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">                CalculateRecursiveAction leftAction = <span class="keyword">new</span> CalculateRecursiveAction(start, middle);</span><br><span class="line">                CalculateRecursiveAction rightAction = <span class="keyword">new</span> CalculateRecursiveAction(middle + <span class="number">1</span>, end);</span><br><span class="line">                <span class="comment">// 执行子任务</span></span><br><span class="line">                invokeAll(leftAction, rightAction);</span><br><span class="line">                <span class="comment">// 没有汇总子任务结果过程，因为没有返回值。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果也是5050。</p><h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h2><p>上面只是为了演示Fork/Join的用法，实际是采用这种方式计算反而更加费时，因为切割任务，分配线程需要额外的开销。其实什么时候用不必太纠结，一个足够大的任务，如果采用Fork/Join来处理比传统处理方式快的话，那就毫不犹豫的选择它吧！</p><p>参考文章：<a href="https://www.imooc.com/article/24822" target="_blank" rel="noopener">https://www.imooc.com/article/24822</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;JDK7提供了一个将任务“分而治之”的框架 — Fork/Join。它把一个大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割。分割的子任务分别放到双端队列里，然后启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Java线程池</title>
    <link href="http://mrbird.cc/Java-Thread-Pool.html"/>
    <id>http://mrbird.cc/Java-Thread-Pool.html</id>
    <published>2019-03-20T12:35:35.000Z</published>
    <updated>2019-07-12T13:02:30.465Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:16 GMT+0800 (GMT+08:00) --><p>在前面的例子中，我们都是通过<code>new Thread</code>来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。<a id="more"></a></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>创建Java线程池最为核心的类为<code>ThreadPoolExecutor</code>：</p><p><img src="img/QQ截图20190630215357.png" alt="QQ截图20190630215357.png"></p><p>它提供了四种构造函数来创建线程池，其中最为核心的构造函数如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p></p><p>这7个参数的含义如下：</p><ol><li><p><strong>corePoolSize</strong> 线程池核心线程数。即线程池中保留的线程个数，即使这些线程是空闲的，也不会被销毁，除非通过ThreadPoolExecutor的<code>allowCoreThreadTimeOut(true)</code>方法开启了核心线程的超时策略；</p></li><li><p><strong>maximumPoolSize</strong> 线程池中允许的最大线程个数；</p></li><li><p><strong>keepAliveTime</strong> 用于设置那些超出核心线程数量的线程的最大等待时间，超过这个时间还没有新任务的话，超出的线程将被销毁；</p></li><li><p><strong>unit</strong> 超时时间单位；</p></li><li><p><strong>workQueue</strong> 线程队列。用于保存通过execute方法提交的，等待被执行的任务；</p></li><li><p><strong>threadFactory</strong> 线程创建工程，即指定怎样创建线程；</p></li><li><p><strong>handler</strong> 拒绝策略。即指定当线程提交的数量超出了maximumPoolSize后，该使用什么策略处理超出的线程。</p></li></ol><p>在通过这个构造方法创建线程池的时候，这几个参数必须满足以下条件，否则将抛出<code>IllegalArgumentException</code>异常：</p><ol><li><p>corePoolSize不能小于0；</p></li><li><p>keepAliveTime不能小于0；</p></li><li><p>maximumPoolSize 不能小于等于0；</p></li><li><p>maximumPoolSize不能小于corePoolSize；</p></li></ol><p>此外，workQueue、threadFactory和handler不能为null，否则将抛出空指针异常。</p><p>下面举些例子来深入理解这几个参数的含义。</p><p>使用上面的构造方法创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码创建了一个核心线程数量为1，允许最大线程数量为2，最大活跃时间为10秒，线程队列长度为1的线程池。</p><p>假如我们通过execute方法向线程池提交1个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">System.out.println(<span class="string">"线程池创建完毕"</span>);</span><br><span class="line"></span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> activeCount = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> queueSize = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeCount != threadPoolExecutor.getActiveCount()</span><br><span class="line">            || queueSize != threadPoolExecutor.getQueue().size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"活跃线程个数 "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">        System.out.println(<span class="string">"核心线程个数 "</span> + threadPoolExecutor.getCorePoolSize());</span><br><span class="line">        System.out.println(<span class="string">"队列线程个数 "</span> + threadPoolExecutor.getQueue().size());</span><br><span class="line">        System.out.println(<span class="string">"最大线程数 "</span> + threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">        activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">        queueSize = threadPoolExecutor.getQueue().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>ThreadPoolExecutor的execute和submit方法都可以向线程池提交任务，区别是，submit方法能够返回执行结果，返回值类型为Future</p></div><p>sleep方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程执行sleep方法"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序，控制台输出如下： <img src="img/QQ截图20190630222238.png" alt="QQ截图20190630222238.png"></p><p>线程池核心线程数量为1，通过execute提交了一个任务后，由于核心线程是空闲的，所以任务被执行了。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。此外，因为提交的任务被核心线程执行了，所以并没有线程需要被放到线程队列里等待，线程队列长度为0。</p><p>假如我们通过execute方法向线程池提交2个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190701183457.png" alt="QQ截图20190701183457.png"></p><p>线程池核心线程数量为1，通过execute提交了2个任务后，一开始核心线程是空闲的，Thread-0被执行。由于这个任务的逻辑是休眠100秒，所以在这100秒内，线程池的活跃线程数量为1。因为核心线程数量为1，所以另外一个任务在这100秒内不能被执行，于是被放到线程队列里等待，线程队列长度为1。</p><p>假如我们通过execute方法向线程池提交3个任务，看看结果如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190701184303.png" alt="QQ截图20190701184303.png"></p><p>这三个任务都是休眠100秒，所以核心线程池中第一个任务正在被执行，第二个任务被放入到了线程队列。而当第三个任务被提交进来时，线程队列满了（我们定义的长度为1），由于该线程池允许的最大线程数量为2，所以线程池还可以再创建一个线程来执行另外一个任务，于是乎之前在线程队列里的线程被取出执行（FIFO），第三个任务被放入到了线程队列。</p><p>改变第二个和第三个任务的睡眠时间，观察输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190701185215.png" alt="QQ截图20190701185215.png"></p><p>第二个任务提交5秒后，任务执行完毕，所以线程队列里的任务被执行，于是队列线程个数为0，活跃线程数量为2（第一个和第三个任务）。再过5秒后，第三个任务执行完毕，于是活跃线程数量为1（第一个100秒还没执行完毕）。</p><p>在第三个任务结束的瞬间，我们观察线程快照:</p><p><img src="img/QQ截图20190701185617.png" alt="QQ截图20190701185617.png"></p><p>可以看到，线程池中有两个线程，Thread-0在执行第一个任务（休眠100秒，还没结束），Thread-1执行完第三个任务后并没有马上被销毁。过段时间后（10秒钟后）再观察线程快照:</p><p><img src="img/QQ截图20190701190444.png" alt="QQ截图20190701190444.png"></p><p>可以看到，Thread-1这个线程被销毁了，因为我们在创建线程池的时候，指定keepAliveTime 为10秒，10秒后，超出核心线程池线程外的那些线程将被销毁。</p><p>假如一次性提交4个任务，看看会怎样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br><span class="line">threadPoolExecutor.execute(() -&gt; sleep(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190701190808.png" alt="QQ截图20190701190808.png"></p><p>因为我们设置的拒绝策略为AbortPolicy，所以最后提交的那个任务直接被拒绝了。更多拒绝策略下面会介绍到。</p><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>线程池包含以下几个状态：</p><p><img src="img/QQ截图20190702100110.png" alt="QQ截图20190702100110.png"></p><p>当线程池中所有任务都处理完毕后，线程并不会自己关闭。我们可以通过调用<code>shutdown</code>和<code>shutdownNow</code>方法来关闭线程池。两者的区别在于：</p><ol><li><p><code>shutdown</code>方法将线程池置为shutdown状态，拒绝新的任务提交，但线程池并不会马上关闭，而是等待所有正在折行的和线程队列里的任务都执行完毕后，线程池才会被关闭。所以这个方法是平滑的关闭线程池。</p></li><li><p><code>shutdownNow</code>方法将线程池置为stop状态，拒绝新的任务提交，中断正在执行的那些任务，并且清除线程队列里的任务并返回。所以这个方法是比较“暴力”的。</p></li></ol><p>举两个例子观察下两者的区别：</p><p><code>shutdown</code>例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdown方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序，控制台输出如下：</p><p><img src="img/QQ截图20190702101041.png" alt="QQ截图20190702101041.png"></p><p>可以看到，虽然在任务都被提交后马上执行了<code>shutdown</code>方法，但是并不会马上关闭线程池，而是等待所有被提交的任务都执行完了才关闭。</p><p><code>shutdownNow</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    List&lt;Runnable&gt; runnables = threadPoolExecutor.shutdownNow(); <span class="comment">// 马上关闭，并返回还未被执行的任务</span></span><br><span class="line">    System.out.println(runnables);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"已经执行了线程池shutdownNow方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序，控制台输出如下： <img src="img/QQ截图20190702101355.png" alt="QQ截图20190702101355.png"></p><p>可以看到，在执行<code>shutdownNow</code>方法后，线程池马上就被关闭了，正在执行中的两个任务被打断，并且返回了线程队列中等待被执行的两个任务。</p><p>通过上面两个例子我们还可以看到<code>shutdown</code>和<code>shutdownNow</code>方法都不是阻塞的。常与<code>shutdown</code>搭配的方法有<code>awaitTermination</code>。</p><p><code>awaitTermination</code>方法接收timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。该方法是阻塞的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask());</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isShutdown = threadPoolExecutor.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isShutdown) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池在3秒内成功关闭"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"等了3秒还没关闭，不等了╰（‵□′）╯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序输出如下：</p><p><img src="img/QQ截图20190702102156.png" alt="QQ截图20190702102156.png"></p><h2 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a>4大拒绝策略</h2><p>当线程池无法再接收新的任务的时候，可采取如下四种策略： <img src="img/QQ截图20190302111014.png" alt="QQ截图20190302111014.png"></p><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><p><code>CallerRunsPolicy</code>策略：由调用线程处理该任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的线程池最多只能一次性提交4个任务，第5个任务提交后会被拒绝策略处理。启动程序输出如下：</p><p><img src="img/QQ截图20190702103818.png" alt="QQ截图20190702103818.png"></p><p>可以看到，第5个提交的任务由调用线程（即main线程）处理该任务。</p><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><p><code>AbortPolicy</code>策略：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。前面的例子就是使用该策略，所以不再演示。</p><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><p><code>DiscardOldestPolicy</code>策略：丢弃最早被放入到线程队列的任务，将新提交的任务放入到线程队列末端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序输出如下：</p><p><img src="img/QQ截图20190702105646.png" alt="QQ截图20190702105646.png"></p><p>可以看到最后提交的任务被执行了，而第3个任务是第一个被放到线程队列的任务，被丢弃了。</p><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><p><code>DiscardPolicy</code>策略：直接丢弃新的任务，不抛异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务1"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务2"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> longTask(<span class="string">"任务3"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务4"</span>));</span><br><span class="line">    threadPoolExecutor.execute(<span class="keyword">new</span> shortTask(<span class="string">"任务5"</span>));</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">shortTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">shortTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行shortTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"shortTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">longTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">longTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"执行longTask-name-"</span> + name + <span class="string">"完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"longTask执行过程中被打断"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序，输出如下： <img src="img/QQ截图20190702110022.png" alt="QQ截图20190702110022.png"></p><p>第5个任务直接被拒绝丢弃了，而没有抛出任何异常。</p><h2 id="线程池工厂方法"><a href="#线程池工厂方法" class="headerlink" title="线程池工厂方法"></a>线程池工厂方法</h2><p>除了使用ThreadPoolExecutor的构造方法创建线程池外，我们也可以使用<code>Executors</code>提供的工厂方法来创建不同类型的线程池：</p><p><img src="img/QQ截图20190702110350.png" alt="QQ截图20190702110350.png"></p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>查看<code>newFixedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到，通过<code>newFixedThreadPool</code>创建的是一个固定大小的线程池，大小由<code>nThreads</code>参数指定，它具有如下几个特点:</p><ol><li><p>因为corePoolSize和maximumPoolSize的值都为nThreads，所以线程池中线程数量永远等于nThreads，不可能新建除了核心线程数的线程来处理任务，即keepAliveTime实际上在这里是无效的。</p></li><li><p>LinkedBlockingQueue是一个无界队列（最大长度为Integer.MAX_VALUE），所以这个线程池理论是可以无限的接收新的任务，这就是为什么上面没有指定拒绝策略的原因。</p></li></ol><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>查看<code>newCachedThreadPool</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是一个理论上无限大小的线程池：</p><ol><li><p>核心线程数为0，SynchronousQueue队列是没有长度的队列，所以当有新的任务提交，如果有空闲的还未超时的（最大空闲时间60秒）线程则执行该任务，否则新增一个线程来处理该任务。</p></li><li><p>因为线程数量没有限制，理论上可以接收无限个新任务，所以这里也没有指定拒绝策略。</p></li></ol><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>查看<code>newSingleThreadExecutor</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol><li><p>核心线程数和最大线程数都为1，每次只能有一个线程处理任务。</p></li><li><p>LinkedBlockingQueue队列可以接收无限个新任务。</p></li></ol><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>查看<code>newScheduledThreadPool</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以<code>newScheduledThreadPool</code>理论是也是可以接收无限个任务，DelayedWorkQueue也是一个无界队列。</p><p>使用newScheduledThreadPool创建的线程池除了可以处理普通的Runnable任务外，它还具有调度的功能：</p><p>1.延迟指定时间后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟5秒执行</span></span><br><span class="line">executorService.schedule(() -&gt; System.out.println(<span class="string">"hello"</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p></p><p>2.按指定的速率执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 延迟1秒执行，然后每5秒执行一次</span></span><br><span class="line">executorService.scheduleAtFixedRate(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190702152117.png" alt="QQ截图20190702152117.png"></p><p>3.按指定的时延执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">executorService.scheduleWithFixedDelay(</span><br><span class="line">        () -&gt; System.out.println(LocalTime.now()), <span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190702152440.png" alt="QQ截图20190702152440.png"></p><p>乍一看，scheduleAtFixedRate和scheduleWithFixedDelay没啥区别，实际它们还是有区别的：</p><ul><li><p>scheduleAtFixedRate按照固定速率执行任务，比如每5秒执行一个任务，即使上一个任务没有结束，5秒后也会开始处理新的任务；</p></li><li><p>scheduleWithFixedDelay按照固定的时延处理任务，比如每延迟5秒执行一个任务，无论上一个任务处理了1秒，1分钟还是1小时，下一个任务总是在上一个任务执行完毕后5秒钟后开始执行。</p></li></ul><p>对于这些线程池工厂方法的使用，阿里巴巴编程规程指出：</p><p><img src="img/QQ截图20190702153306.png" alt="QQ截图20190702153306.png"></p><p>因为这几个线程池理论是都可以接收无限个任务，所以这就有内存溢出的风险。实际上只要我们掌握了ThreadPoolExecutor构造函数7个参数的含义，我们就可以根据不同的业务来创建出符合需求的线程池。一般线程池的创建可以参考如下规则：</p><ul><li><p>IO密集型任务，线程池线程数量可以设置为2 X CPU核心数；</p></li><li><p>计算密集型任务，线程池线程数量可以设置为CPU核心数 + 1。</p></li></ul><h2 id="一些API的用法"><a href="#一些API的用法" class="headerlink" title="一些API的用法"></a>一些API的用法</h2><p>ThreadPoolExecutor提供了几个判断线程池状态的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"线程池为shutdown状态："</span> + threadPoolExecutor.isShutdown());</span><br><span class="line">    System.out.println(<span class="string">"线程池正在关闭："</span> + threadPoolExecutor.isTerminating());</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭："</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">    threadPoolExecutor.awaitTermination(<span class="number">6</span>, TimeUnit.SECONDS);</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭"</span> + threadPoolExecutor.isTerminated());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：</p><p><img src="img/20190703205843.png" alt="20190703205843.png"></p><p>前面我们提到，线程池核心线程即使是空闲状态也不会被销毁，除非使用<code>allowCoreThreadTimeOut</code>设置了允许核心线程超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">               <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">               <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下所示：</p><p><img src="img/asdfasdfaaaaa.gif" alt="asdfasdfaaaaa.gif"></p><p>5秒后任务执行完毕，核心线程处于空闲的状态。因为通过<code>allowCoreThreadTimeOut</code>方法设置了允许核心线程超时，所以3秒后（keepAliveTime设置为3秒），核心线程被销毁。核心线程被销毁后，线程池也就没有作用了，于是就自动关闭了。</p><div class="note danger"><p>值得注意的是，如果一个线程池调用了<code>allowCoreThreadTimeOut(true)</code>方法，那么它的<code>keepAliveTime</code>不能为0。</p></div><p>ThreadPoolExecutor提供了一<code>remove</code>方法，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可看到，它删除的是线程队列中的任务，而非正在被执行的任务。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Runnable r = () -&gt; System.out.println(<span class="string">"看看我是否会被删除"</span>);</span><br><span class="line">    threadPoolExecutor.execute(r);</span><br><span class="line">    threadPoolExecutor.remove(r);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>执行程序，输出如下：</p><p><img src="img/QQ截图20190703211746.png" alt="QQ截图20190703211746.png"></p><p>可看到任务并没有被执行，已经被删除，因为唯一一个核心线程已经在执行任务了，所以后提交的这个任务被放到了线程队列里，然后通过remove方法删除。</p><p>默认情况下，只有当往线程池里提交了任务后，线程池才会启动核心线程处理任务。我们可以通过调用<code>prestartCoreThread</code>方法，让核心线程即使没有任务提交，也处于等待执行任务的活跃状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">    threadPoolExecutor.prestartCoreThread();</span><br><span class="line">    System.out.println(<span class="string">"活跃线程数: "</span> + threadPoolExecutor.getActiveCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下所示：</p><p><img src="img/QQ截图20190703213145.png" alt="QQ截图20190703213145.png"></p><p>该方法返回boolean类型值，如果所以核心线程都启动了，返回false，反之返回true。</p><p>还有一个和它类似的<code>prestartAllCoreThreads</code>方法，它的作用是一次性启动所有核心线程，让其处于活跃地等待执行任务的状态。</p><p>ThreadPoolExecutor的invokeAny方法用于随机执行任务集合中的某个任务，并返回执行结果，该方法是同步方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务集合</span></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">// 随机执行结果</span></span><br><span class="line">    Integer result = threadPoolExecutor.invokeAny(tasks);</span><br><span class="line">    System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动程序，输出如下：</p><p><img src="img/QQ截图20190704091530.png" alt="QQ截图20190704091530.png"></p><p>ThreadPoolExecutor的invokeAll则是执行任务集合中的所有任务，返回Future集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), (ThreadFactory) Thread::<span class="keyword">new</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; tasks = IntStream.range(<span class="number">0</span>, <span class="number">4</span>).boxed().map(i -&gt; (Callable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextInt(<span class="number">5</span>));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Future&lt;Integer&gt;&gt; futureList = threadPoolExecutor.invokeAll(tasks);</span><br><span class="line">    futureList.stream().map(f-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    threadPoolExecutor.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下： <img src="img/QQ截图20190704091836.png" alt="QQ截图20190704091836.png"></p><p>总结下这些方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td>allowCoreThreadTimeOut(boolean value)</td><td>是否允许核心线程空闲后超时，是的话超时后核心线程将销毁，线程池自动关闭</td></tr><tr><td>awaitTermination(long timeout, TimeUnit unit)</td><td>阻塞当前线程，等待线程池关闭，timeout用于指定等待时间。</td></tr><tr><td>execute(Runnable command)</td><td>向线程池提交任务，没有返回值</td></tr><tr><td>submit(Runnable task)</td><td>向线程池提交任务，返回Future</td></tr><tr><td>isShutdown()</td><td>判断线程池是否为shutdown状态</td></tr><tr><td>isTerminating()</td><td>判断线程池是否正在关闭</td></tr><tr><td>isTerminated()</td><td>判断线程池是否已经关闭</td></tr><tr><td>remove(Runnable task)</td><td>移除线程队列中的指定任务</td></tr><tr><td>prestartCoreThread()</td><td>提前让一个核心线程处于活跃状态，等待执行任务</td></tr><tr><td>prestartAllCoreThreads()</td><td>提前让所有核心线程处于活跃状态，等待执行任务</td></tr><tr><td>getActiveCount()</td><td>获取线程池活跃线程数</td></tr><tr><td>getCorePoolSize()</td><td>获取线程池核心线程数</td></tr><tr><td>threadPoolExecutor.getQueue()</td><td>获取线程池线程队列</td></tr><tr><td>getMaximumPoolSize()</td><td>获取线程池最大线程数</td></tr><tr><td>shutdown()</td><td>让线程池处于shutdown状态，不再接收任务，等待所有正在运行中的任务结束后，关闭线程池。</td></tr><tr><td>shutdownNow()</td><td>让线程池处于stop状态，不再接受任务，尝试打断正在运行中的任务，并关闭线程池，返回线程队列中的任务。</td></tr></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:16 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在前面的例子中，我们都是通过&lt;code&gt;new Thread&lt;/code&gt;来创建一个线程，由于线程的创建和销毁都需要消耗一定的CPU资源，所以在高并发下这种创建线程的方式将严重影响代码执行效率。而线程池的作用就是让一个线程执行结束后不马上销毁，继续执行新的任务，这样就节省了不断创建线程和销毁线程的开销。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency Lock</title>
    <link href="http://mrbird.cc/Java-Concurrency-Lock.html"/>
    <id>http://mrbird.cc/Java-Concurrency-Lock.html</id>
    <published>2019-03-16T01:37:15.000Z</published>
    <updated>2019-07-12T13:02:30.461Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --><p>Lock锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。</p><a id="more"></a><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock字面上意思就是可重入锁，表示该锁能够支持一个线程对资源的重复加锁。定义一个ReentrantLock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p></p><p>默认无参构造函数创建的是非公平锁，构造函数重载方法<code>ReentrantLock(boolean fair)</code>支持传入<code>true</code>创建公平锁。公平锁的意思是多线程在获取锁的时候是公平的，也就是等待时间最长的线程最优先获取锁，类似FIFO。</p><p>使用ReentrantLock可以实现和synchronized一样的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach(i -&gt; <span class="keyword">new</span> Thread(ReentrantLockTest::needLock).start());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note danger"><p>确保在finally里释放锁，否则容易造成死锁。</p></div><p>上面例子同一时刻只能有一个线程可以获得锁<code>lock</code>，别的线程必须等待锁被释放（<code>unlock</code>）才能开始竞争获取锁。程序运行结果如下所示：</p><p><img src="img/fasdfasdf.gif" alt="sdfsdaaa.gif"></p><p><code>needLock</code>方法和下面通过synchronized关键字实现锁方法效果是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">needLockBySync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ReentrantLockTest.class) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>lock</code>方法是不可被打断的，即调用线程的<code>interrupt</code>方法不起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockUnInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockUnInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 不可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:</p><p><img src="img/QQ截图20190517140102.png" alt="QQ截图20190517140102.png"></p><p><img src="img/QQ截图20190517140138.png" alt="QQ截图20190517140138.png"></p><p>thread2(Thread-1)依旧在继续等待获取锁，没有被打断。</p><p>ReentrantLock提供了可打断获取锁的方法<code>lockInterruptibly</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testLockInterruptibly);</span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLockInterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly(); <span class="comment">// 可以被打断</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/sfasdfasfdasdfa.png" alt="QQ截图20190517140645.png"></p><p>thread2在等待获取锁时被打断，抛出<code>InterruptedException</code>异常。</p><p>ReentrantLock的<code>tryLock</code>方法用于尝试获取锁，返回boolean类型，表示获取锁成功与否：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">"thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ReentrantLockTest::testTryLock, <span class="string">"thread2"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"没有获取到锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190517142035.png" alt="QQ截图20190517142035.png"></p><p>thread1抢到锁后进入死循环，一直不释放锁。thread2尝试获取锁失败后直接放弃。</p><p><code>tryLock</code>的重载方法<code>tryLock(long timeout, TimeUnit unit)</code>可以设置尝试获取锁的时间范围，超过这个时间没有获取到锁则返回false。</p><p>ReentrantLock一些别的方法：</p><table><tr><th>方法</th><th>含义</th></tr><tr><td><code>getQueueLength()</code></td><td>等待获取锁线程数量</td></tr><tr><td><code>hasQueuedThreads()</code></td><td>是否有在等待获取锁的线程</td></tr><tr><td><code>hasQueuedThread(Thread thread)</code></td><td>等待获取锁的线程队列里是包含指定的线程</td></tr><tr><td><code>isLocked</code></td><td>当前锁是否被任意一个线程获取到了</td></tr></table><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock为读写锁。ReentrantLock为排他锁，同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p>简而言之，ReadWriteLock包含读写锁，遵循以下规则：</p><ul><li><p>写的时候不能读</p></li><li><p>写的时候不能写</p></li><li><p>读的时候不能写</p></li><li><p>读的时候可以读</p></li></ul><p>ReadWriteLock为接口，我们使用它的实现类ReentrantReadWriteLock创建读写锁实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br></pre></td></tr></table></figure><p></p><p>使用读写锁创建一个读写的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line">    <span class="comment">// 存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"writer"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"reader"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock(); <span class="comment">// 写锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写入value: "</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String value = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"读取data: "</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/xxxxxxxxx.gif" alt="xxxxxxxxx.gif"></p><p>ReentrantReadWriteLock还包含了一些别的实用方法：</p><p><img src="img/QQ截图20190517153100.png" alt="QQ截图20190517153100.png"></p><p>功能和上面介绍的ReentrantLock差不多，方法名见名知其意，不再演示了。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition接口提供了类似Object的<code>wait</code>、<code>notify</code>和<code>notifyAll</code>方法，与Lock配合可以实现生产/消费模式，但是这两者在使用方式以及功能特性上还是有差别的。</p><p>使用Codition实现一个生产消费的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"producer"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"consumer"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果没有被消费则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produce data = "</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>; <span class="comment">// 生产完数据将消费标识置为false</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，用于通知消费者可以开始消费了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123; <span class="comment">// 判断数据是否被消费</span></span><br><span class="line">                condition.await(); <span class="comment">// 如果被消费了则进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" consume data = "</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>; <span class="comment">// 消费完将消费标识置为true</span></span><br><span class="line">            condition.signal(); <span class="comment">// 解除await，哟领域通知生产者可以开始生产了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子中，通过<code>consumed</code>判断数据是否被消费。<code>produceData</code>方法在获取锁后，判断数据是否被消费，如果没有被消费，则调用Condition的<code>await</code>方法进入等待，直到Condition对象的<code>signal</code>方法被调用；<code>consumeData</code>方法逻辑和<code>produceData</code>一致。</p><p>Condition核心用法就是通过<code>await</code>方法让线程进入阻塞等待状态，通过<code>signal</code>解除阻塞状态。上面的例子运行效果如下所示：</p><p><img src="img/eososos.gif" alt="eososos.gif"></p><p>对应上面的例子我们可以思考下面三个问题：</p><ol><li><p>是否可以只使用Lock而不使用Condition？</p></li><li><p>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</p></li><li><p>是否可以只使用Condition不使用Lock？</p></li></ol><p>对于第一个问题：<strong>是否可以只使用Lock而不使用Condition？</strong></p><p>虽然我们可以定义公平的ReentrantLock，但是实际上并不能确保100%公平，只是尽可能的公平。生产消费模型必须为生产者生成完了数据通知消费者消费，消费者消费完了通知生产者生产，这是环环相扣的，不允许出现别的情况。</p><p>对于第二个问题：<strong>生产者抢到了锁进入await，并没有释放锁，为什么消费者可以获得锁？</strong></p><p>假如一开始<code>produceData</code>方法先通过<code>lock.lock()</code>获取到了锁，consumed初始值为false，所以接着方法会调用<code>condition.await()</code>进入阻塞等待。<code>await</code>方法会使得当前线程<strong>释放锁对象</strong>，然后进入休眠状态，直到发生下面三种情况之一才会被解除休眠：</p><ol><li><p>Condition的<code>signal</code>方法被调用；</p></li><li><p>Condition的<code>signalAll</code>方法被调用；</p></li><li><p>其他线程调用了当前线程的<code>interrupt</code>方法。</p></li></ol><p>对于第三个问题：<strong>是否可以只使用Condition不使用Lock？</strong></p><p>既然<code>await</code>会使得线程进入阻塞等待状态，那么是否可以直接使用<code>await</code>，而不使用Lock呢？我们改造上面的例子，去掉获取和释放锁的相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公平锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 初始数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否被消费</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consumed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produce data = "</span> + data);</span><br><span class="line">            consumed = <span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (consumed) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" consume data = "</span> + data);</span><br><span class="line">            consumed = <span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190517152744.png" alt="QQ截图20190517152744.png"></p><p>可以看到，程序抛出<code>IllegalMonitorStateException</code>异常，所以Condition必须配合Lock使用。</p><p>正如前面说的，Condition的功能类似于Object对象的<code>wait</code>和<code>notify</code>方法，下面我们使用Object对象的<code>wait</code>和<code>notify</code>方法实现一个类似上面生产消费的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> used = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object MONITOR = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                produceData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                consumeData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 生产data = "</span> + data);</span><br><span class="line">            used = <span class="keyword">false</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MONITOR) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    MONITOR.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 消费data = "</span> + data);</span><br><span class="line">            used = <span class="keyword">true</span>;</span><br><span class="line">            MONITOR.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>效果如下所示：</p><p><img src="img/baoningn.gif" alt="baoningn.gif"></p><h2 id="JDK8-StampedLock"><a href="#JDK8-StampedLock" class="headerlink" title="JDK8 StampedLock"></a>JDK8 StampedLock</h2><p>JDK8 新增了一个锁StampedLock，它是对ReadWriteLock的改进。</p><p>使用ReadWriteLock的时候，当读线程数量远大于写线程数量的时候就会出现“写饥饿”现象。因为锁大概率都被读线程抢走了，写线程很难抢到锁，这将使得读写效率非常低下。</p><p>JDK8的StampedLock就是为了解决这个问题而设计的，StampedLock包含<strong>乐观锁</strong>和<strong>悲观锁</strong>：</p><ul><li><p>乐观锁：每次去拿数据的时候，并不获取锁对象，而是判断标记位（stamp）是否有被修改，如果有修改就再去读一次。</p></li><li><p>悲观锁：每次拿数据的时候都去获取锁。</p></li></ul><p>通过乐观锁，当写线程没有写数据的时候，标志位stamp并没有改变，所以即使有再多的读线程在读取数据，它们都可以直接去读数据，而无需获取锁，这就不会使得写线程抢不到锁了。</p><div class="note info"><p>stamp类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的stamp值。</p></div><p>下面我们通过一个例子来模拟写饥饿的情况：创建20个线程，其中19个线程用于读数据，1个线程用于写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest::read;</span><br><span class="line">        Runnable write = StampedLockTest::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock(); <span class="comment">// 获取悲观锁，阻塞写线程</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" read value: "</span> + collect);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" write value: "</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子通过StampedLock调用<code>writeLock</code>、<code>unlockWrite</code>、<code>readLock</code>和<code>unlockRead</code>的时候都会导致StampedLock的stamp值的变化，即每次+1，直到加到最大值，然后从0重新开始。</p><p>上面程序运行结果如下： <img src="img/QQ截图20190517155259.png" alt="QQ截图20190517155259.png"></p><p>可以看到写线程最后才抢到锁并写入数据。</p><p>我们通过乐观锁来改善这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Long&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Runnable read = StampedLockTest2::read;</span><br><span class="line">        Runnable write = StampedLockTest2::write;</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">19</span>).forEach(i -&gt; executorService.submit(read));</span><br><span class="line">        executorService.submit(write);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = lock.tryOptimisticRead(); <span class="comment">// 获取乐观锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接读取值</span></span><br><span class="line">        String collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果戳被改变，方法返回false，说明stamped被修改过了（被write方法修改过了，有新的数据写入），</span></span><br><span class="line">        <span class="comment">// 那么重新获取锁并去读取值，否则直接使用上面读取的值。</span></span><br><span class="line">        <span class="keyword">if</span> (!lock.validate(stamped)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stamped = lock.readLock();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                collect = data.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlockRead(stamped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" read value: "</span> + collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.writeLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> value = System.currentTimeMillis();</span><br><span class="line">            data.add(value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" write value: "</span> + value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们重点关注<code>read</code>方法。<code>read</code>方法一开始通过调用StampedLock的<code>tryOptimisticRead</code>方法来获取标志位stamp，获取乐观锁并不会真正的去获取锁（所以不会阻塞写操作），然后直接去读数据。接着通过StampedLock的<code>validate</code>方法判断标志位stamp是否被修改了（<code>write</code>方法里会修改标志位的值），如果方法返回true，则说明数据没有被修改过，直接使用前面读取的数据即可；否则需要去获取锁重新去读数据，阻止写操作。</p><p>上面例子运行结果如下：</p><p><img src="img/QQ截图20190517160314.png" alt="QQ截图20190517160314.png"></p><p>可以看到，写操作一开始就抢到了锁，并写入了数据。</p><p><strong>简而言之，StampedLock解决了在没有新数据写入时，由于过多读操作抢夺锁而使得写操作一直获取不到锁无法写入新数据的问题。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Lock锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal使用学习</title>
    <link href="http://mrbird.cc/ThreadLocal.html"/>
    <id>http://mrbird.cc/ThreadLocal.html</id>
    <published>2019-03-15T08:21:35.000Z</published>
    <updated>2019-07-12T13:02:30.556Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>ThreadLocal字面上的意思是局部线程变量，每个线程通过ThreadLocal的<code>get</code>和<code>set</code>方法来访问和修改线程自己独有的变量。简单地说，ThreadLocal的作用就是为每一个线程提供了一个独立的变量副本，每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。<a id="more"></a></p><h2 id="ThreadLocal的基本使用"><a href="#ThreadLocal的基本使用" class="headerlink" title="ThreadLocal的基本使用"></a>ThreadLocal的基本使用</h2><p>ThreadLocal是一个泛型类，在创建的时候需要指定变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure><p></p><p>ThreadLocal提供了<code>set</code>方法来设置变量的值，<code>get</code>方法获取变量的值，<code>remove</code>方法移除变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">"mrbird"</span>);</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下： <img src="img/QQ截图20190515100033.png" alt="QQ截图20190515100033.png"></p><p>我们也可以给ThreadLocal设置初始值，设置初始值有两种方式：</p><ol><li>重写<code>initialValue</code>方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"初始值"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(threadLocal.get()); <span class="comment">// 初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用ThreadLocal的<code>withInitial</code>方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">"初始值"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(threadLocal.get()); <span class="comment">// 初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是<code>remove</code>无法移除初始值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">"初始值"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">        System.out.println(threadLocal.get()); <span class="comment">// 初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="演示多线程间独立"><a href="#演示多线程间独立" class="headerlink" title="演示多线程间独立"></a>演示多线程间独立</h2><p>在多个线程中使用ThreadLocal：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="string">"thread t1"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="string">"thread t2"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：</p><p><img src="img/QQ截图20190515100702.png" alt="QQ截图20190515100702.png"></p><p>结果证明了ThreadLocal在每个线程间是相互独立的，threadLocal在thread1、thread2和main线程间都有一份独立拷贝。</p><h2 id="ThreadLocal基本原理"><a href="#ThreadLocal基本原理" class="headerlink" title="ThreadLocal基本原理"></a>ThreadLocal基本原理</h2><p>在ThreadLocal类中有一个静态内部类ThreadLocalMap(概念上类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本。</p><p>我们使用Map来代替ThreadLocalMap，创建一个简易的类ThreadLocal实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Thread, T&gt; threadLocalMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Thread key = Thread.currentThread();</span><br><span class="line">            threadLocalMap.put(key, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Thread key = Thread.currentThread();</span><br><span class="line">            T t = threadLocalMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> initalValue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">initalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用方式和之前的例子一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> MyThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">initalValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"initalValue"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="string">"thread t1"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="string">"thread t2"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：</p><p><img src="img/QQ截图20190515101510.png" alt="QQ截图20190515101510.png"></p><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><p>将ThreadLocal变量指定为<code>private static</code>；</p></li><li><p>使用完毕后显式地调用<code>remove</code>方法移除。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ThreadLocal字面上的意思是局部线程变量，每个线程通过ThreadLocal的&lt;code&gt;get&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;方法来访问和修改线程自己独有的变量。简单地说，ThreadLocal的作用就是为每一个线程提供了一个独立的变量副本，每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Semaphore</title>
    <link href="http://mrbird.cc/JUC-Semaphore.html"/>
    <id>http://mrbird.cc/JUC-Semaphore.html</id>
    <published>2019-03-11T08:24:16.000Z</published>
    <updated>2019-07-12T13:02:30.458Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --><p>JUC的Semaphore俗称信号量，可用来控制同时访问特定资源的线程数量。通过它的构造函数我们可以指定信号量（称为许可证permits可能更为明确）的数量，线程可以调用Semaphore对象的<code>acquire</code>方法获取一个许可证，调用<code>release</code>来归还一个许可证。</p><p>下面举个Semaphore的基本使用示例。<a id="more"></a></p><h2 id="Semaphore示例"><a href="#Semaphore示例" class="headerlink" title="Semaphore示例"></a>Semaphore示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 一次拿一个许可证</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取许可证"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"释放许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">            &#125;, <span class="string">"thread"</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，我们定义许可证的数量为2个，然后4个线程通过<code>acquire</code>方法去获取许可证，结束行通过<code>release</code>方法释放许可证。<code>acquire</code>方法默认一次只拿一个许可证，所以上面的例子中，同一时刻最多只有两个线程同时执行。</p><p>程序输出如下所示： <img src="img/asfasdfa.gif" alt="asfasdfa.gif"></p><p><code>acquire</code>的重载方法<code>acquire(int permits)</code>允许线程一次性获取N个许可证；同样的<code>release</code>的重载方法<code>release(int permits)</code>允许线程一次性释放N个许可证。</p><p>Semaphore还有一个<code>tryAcquire</code>，它允许线程尝试去获取1个许可证，如果许可证不足没有获取到的话，线程也会继续执行，而非阻塞等待。<code>tryAcquire</code>方法的重载方法<code>tryAcquire(long timeout, TimeUnit unit)</code>可以指定尝试获取许可证的超时时间。</p><h2 id="acquireUninterruptibly"><a href="#acquireUninterruptibly" class="headerlink" title="acquireUninterruptibly"></a>acquireUninterruptibly</h2><p>从上面的例子我们会发现<code>acquire</code>方法会抛出<code>InterruptedException</code>异常，说明这个方法是可以被打断的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">"semaphore InterruptedException"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子thread1线程获取2个许可证，但许可证总数只有1个，所以会阻塞等待。main线程通过调用thread1的<code>interrupt</code>方法去打断thread1线程，结果如下：</p><p><img src="img/QQ截图20190515164441.png" alt="QQ截图20190515164441.png"></p><p>而通过<code>acquireUninterruptibly</code>方法去获取许可证是不可被打断的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            semaphore.acquireUninterruptibly(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面程序并不会抛出<code>InterruptedException</code>，thread1会一直处于阻塞状态。</p><h2 id="drainPermits"><a href="#drainPermits" class="headerlink" title="drainPermits"></a>drainPermits</h2><p><code>drainPermits</code>方法一次性获取所有许可证（drain抽干榨干😮）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"availablePermits: "</span> + semaphore.availablePermits());</span><br><span class="line">            semaphore.drainPermits(); <span class="comment">// 获取所有许可证，抽干</span></span><br><span class="line">            System.out.println(<span class="string">"availablePermits: "</span> + semaphore.availablePermits());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            semaphore.release(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>availablePermits</code>方法用于获取当前可用许可证数量的预估值。程序输出如下：</p><p><img src="img/QQ截图20190515164951.png" alt="QQ截图20190515164951.png"></p><h2 id="别的API"><a href="#别的API" class="headerlink" title="别的API"></a>别的API</h2><p><code>hasQueuedThreads</code>方法用于判断是否有处于等待获取许可证状态的线程；<code>getQueueLength</code>用于获取处于等待获取许可证状态的线程的数量；<code>getQueuedThreads</code>用于获取处于等待获取许可证状态的线程集合。</p><p><code>getQueuedThreads</code>是<code>protected</code>的，所以要使用它，我们得自定义一个Semaphore的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义许可证数量</span></span><br><span class="line">        <span class="keyword">final</span> MySemaphore semaphore = <span class="keyword">new</span> MySemaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">4</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"获取许可证"</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"释放许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"结束"</span>);</span><br><span class="line">            &#125;, <span class="string">"thread"</span> + (i + <span class="number">1</span>)).start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (semaphore.hasQueuedThreads()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待线程数量："</span> + semaphore.getQueueLength());</span><br><span class="line">                Collection&lt;Thread&gt; queuedThreads = semaphore.getQueuedThreads();</span><br><span class="line">                System.out.println(<span class="string">"等待线程："</span> + queuedThreads.stream().map(Thread::getName).collect(Collectors.joining(<span class="string">","</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySemaphore</span> <span class="keyword">extends</span> <span class="title">Semaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2595494765642942297L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySemaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(permits, fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getQueuedThreads();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下所示（截取一部分）： <img src="img/QQ截图20190515165623.png" alt="QQ截图20190515165623.png"></p><h2 id="Api总结"><a href="#Api总结" class="headerlink" title="Api总结"></a>Api总结</h2><p>总结下Semaphore常用的方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td><code>acquire()</code></td><td>获取一个许可证，可以被打断，没有足够的许可证时阻塞等待</td></tr><tr><td><code>acquire(int permits)</code></td><td>获取指定数量的许可证，可以被打断，没有足够的许可证时阻塞等待</td></tr><tr><td><code>acquireUninterruptibly()</code></td><td>获取一个许可证，不可被打断，没有足够的许可证时阻塞等待</td></tr><tr><td><code>acquireUninterruptibly(int permits)</code></td><td>获取指定数量的许可证，不可被打断，没有足够的许可证时阻塞等待</td></tr><tr><td><code>tryAcquire()</code></td><td>尝试获取一个许可证，没有足够的许可证时程序继续执行，不会被阻塞</td></tr><tr><td><code>tryAcquire(int permits)</code></td><td>尝试获取指定数量的许可证，没有足够的许可证时程序继续执行，不会被阻塞</td></tr><tr><td><code>tryAcquire(long timeout, TimeUnit unit)</code></td><td>在指定的时间范围内尝试获取1个许可证，没有足够的许可证时程序继续执行，<br>不会被阻塞，在该时间方位内可以被打断</td></tr><tr><td><code>tryAcquire(int permits, long timeout, TimeUnit unit)</code></td><td>在指定的时间范围内尝试获取指定数量的许可证，没有足够的许可证时程序<br>继续执行，不会被阻塞，在该时间方位内可以被打断</td></tr><tr><td><code>release()</code></td><td>释放一个许可证</td></tr><tr><td><code>drainPermits()</code></td><td>一次性获取所有可用的许可证</td></tr><tr><td><code>availablePermits()</code></td><td>获取当前可用许可证数量的预估值</td></tr><tr><td><code>hasQueuedThreads()</code></td><td>判断是否有处于等待获取许可证状态的线程</td></tr><tr><td><code>getQueueLength()</code></td><td>获取处于等待获取许可证状态的线程的数量的预估值</td></tr><tr><td><code>getQueuedThreads()</code></td><td>获取处于等待获取许可证状态的线程集合</td></tr></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;JUC的Semaphore俗称信号量，可用来控制同时访问特定资源的线程数量。通过它的构造函数我们可以指定信号量（称为许可证permits可能更为明确）的数量，线程可以调用Semaphore对象的&lt;code&gt;acquire&lt;/code&gt;方法获取一个许可证，调用&lt;code&gt;release&lt;/code&gt;来归还一个许可证。&lt;/p&gt;&lt;p&gt;下面举个Semaphore的基本使用示例。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入理解volatile关键字</title>
    <link href="http://mrbird.cc/volatile.html"/>
    <id>http://mrbird.cc/volatile.html</id>
    <published>2019-03-10T08:20:41.000Z</published>
    <updated>2019-07-12T13:02:30.583Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --><p>volatile关键字修饰的成员变量具有两大特性：保证了该成员变量在不同线程之间的可见性；禁止对该成员变量进行重排序，也就保证了其有序性。但是volatile修饰的成员变量并不具有原子性，在并发下对它的修改是线程不安全的。下面分别举例来演示这两个特性，并且分析为什么volatile不是线程安全的。</p><a id="more"></a><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>通过对<a href="/Java-Memory-model.html">JMM</a>的学习，我们都知道线程对主内存中共享变量的修改首先会从主内存获取值的拷贝，然后保存到线程的工作内存中。接着在工作内存中对值进行修改，最终刷回主内存。由于不同线程拥有各自的工作内存，所以它们对某个共享变量值的修改在没有刷回主内存的时候只对自己可见。</p><p>举个例子，假如有两个线程，其中一个线程用于修改共享变量value，另一个线程用于获取修改后的value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取更新后的值："</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"reader"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">"将值更新为："</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"writer"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>writer线程每隔0.5秒将INIT_VALUE值递增，直到INIT_VALUE大于等于5。而reader线程则是不停的去获取INIT_VALUE的值，直到INIT_VALUE的值大于等于5。程序执行结果如下：</p><p><img src="img/QQ截图20190514143804.png" alt="QQ截图20190514143804.png"></p><p><img src="img/QQ截图20190514150227.png" alt="QQ截图20190514150227.png"></p><p>多执行几次可能每次结果都不一样，但是可以确定的是，writer对值的修改reader并不能马上感知到（如果能感知到的话，reader线程就不会停不下来了）。</p><p>为什么会出现上面的结果呢？因为writer线程在工作内存中修改了INIT_VALUE的值，即使它刷回主内存了，但是reader线程在此之前已经从主内存获取了INIT_VALUE的值（因为线程获取CPU时间片不确定性，这个值可能是0，也可能是被writer修改后的值，但writer线程是每隔0.5秒才会去修改值，所以reader获取到的INIT_VALUE的值一般不会是writer修改的最终值5），并保存到了reader线程的工作内存中。reader线程通过while不断的轮询判断value和INIT_VALUE的值是否相等，但是由于reader线程工作内存中已经有INIT_VALUE的值的拷贝了，所以reader并不会重新从主内存中获取被writer修改后的INIT_VALUE的值，reader线程里while条件一直成立，这就是为什么reader线程不会正常停止并且没有输出修改后的值的原因。</p><p>修改上面的例子，将INIT_VALUE成员变量使用volatile关键字修饰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (value &lt; LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取更新后的值："</span> + INIT_VALUE);</span><br><span class="line">                    value = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"reader"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> value = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; LIMIT) &#123;</span><br><span class="line">                System.out.println(<span class="string">"将值更新为："</span> + ++value);</span><br><span class="line">                INIT_VALUE = value;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"writer"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190514145045.png" alt="QQ截图20190514145045.png"></p><p>可以看到，reader线程已经可以正常停止了，因为最终INIT_VALUE的值肯定是5，并且reader可以感知到这个值被修改为5了。</p><p>为什么volatile修饰的成员变量在线程间具有可见性呢？因为通过volatile修饰，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，加了这个指令后，会引发两件事情：</p><ol><li><p>将当前处理器缓存行的内容写回到系统内存，也就是强制将工作内存中的值刷回主内存；</p></li><li><p>这个写回到内存的操作会使得在其他CPU里缓存了该内存地址的数据失效。其他CPU缓存数据失效，则会重新去内存中读取值，也就是被修改的数据。</p></li></ol><p>通过上面这两个特性，我们可以确定的是，writer对值进行修改并刷回主内存后，reader里INIT_VALUE值的拷贝就失效了，所以reader线程会再次从主内存中获取INIT_VALUE的值，这时候这个值已经是被writer线程修改刷新后的值了。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>来看一个线程不安全的单例实现（双重同步锁单例模式，更多关于单例的介绍可以参考<a href="/singleton.html">单例的几种写法和对比</a>）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的例子虽然加了同步锁，但是在多线程下并不是线程安全的。第12行<code>instance = new SingletonTest()</code>在实际执行的时候会被拆分为以下三个步骤:</p><ol><li><p>分配存储SingletonTest对象的内存空间；</p></li><li><p>初始化SingletonTest对象；</p></li><li><p>将instance指向刚刚分配的内存空间。</p></li></ol><p>通过JMM的学习我们都知道，在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，因为第2步和第3步并没有依赖关系，所以可能发生重排序，排序后的步骤为：</p><ol><li><p>分配存储SingletonTest对象的内存空间；</p></li><li><p>将instance指向刚刚分配的内存空间；</p></li><li><p>初始化SingletonTest对象。</p></li></ol><p>经过重排序后，上面的例子在多线程下就会出现问题。假如现在有两个线程A和B同时调用SingletonTest#getInstance，线程A执行到了代码的第12行<code>instance = new SingletonTest()</code>，已经完成了对象内存空间的分配并将instance指向了该内存空间，线程B执行到了第9行，发现instance并不是null（因为已经指向了内存空间），所以就直接返回instance了。但是线程A并还没有执行初始化SingletonTest操作，所以实际线程B拿到的SingletonTest实例是空的，那么线程B后续对SingletonTest操控将抛出空指针异常。</p><p>要让上面的例子是线程安全的，只需要用volatile修饰单例对象即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数，让外部没办法直接通过new来创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双重检测</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为通过volatile修饰的成员变量会添加内存屏障来阻止JVM进行指令重排优化。</p><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>举个递增的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; IntStream.range(<span class="number">0</span>, <span class="number">500</span>).forEach(i -&gt; value += <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>多次运行上面的例子：</p><p><img src="img/asdfjwqefj.gif" alt="asdfjwqefj.gif"></p><p>可以看到最终的值有可能小于1000。</p><p>volatile可以保证修改的值能够马上更新到主内存，其他线程也会捕捉到被修改后的值，那么为什么不能保证原子性呢？</p><p>因为在Java中，只有对基本类型的赋值和修改才是原子性的，而对共享变量的修改并不是原子性的。通过<a href="/Java-Memory-model.html">JMM</a>内存交互协议我们可以知道，一个线程修改共享变量的值需要经过下面这些步骤：</p><ol><li><p>线程从主内存中读取（read）共享变量的值，然后载入（load）到线程的工作内存中的变量；</p></li><li><p>使用（use）工作内存变量的值，执行加减操作，然后将修改后的值赋值（assign）给工作内存中的变量；</p></li><li><p>将工作内存中修改后的变量的值存储（store）到主内存中，并执行写入（write）操作。</p></li></ol><p>所以上面的例子中，可能出现下面这种情况：</p><p>thread1和thread2同时获取了value的值，比如为100。thread1执行了+1操作，然后写回主内存，这个时候thread2刚好执行完use操作（+1），准备执行assign（将+1后的值写回工作内存对应的变量中）操作。虽然这时候thread2工作内存中value值的拷贝无效了（因为volatile的特性），但是thread2已经执行完+1操作了，它并不需要再从主内存中获取value的值，所以thread2可以顺利地将+1后的值赋值给工作内存中的变量，然后刷回主存。这就是为什么上面的累加结果可能会小于1000的原因。</p><p>要让上面的例子是线程安全的话可以加同步锁，或者使用atomic类，后续会介绍到。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;volatile关键字修饰的成员变量具有两大特性：保证了该成员变量在不同线程之间的可见性；禁止对该成员变量进行重排序，也就保证了其有序性。但是volatile修饰的成员变量并不具有原子性，在并发下对它的修改是线程不安全的。下面分别举例来演示这两个特性，并且分析为什么volatile不是线程安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUC之Exchanger</title>
    <link href="http://mrbird.cc/JUC-Exchanger.html"/>
    <id>http://mrbird.cc/JUC-Exchanger.html</id>
    <published>2019-03-06T08:24:53.000Z</published>
    <updated>2019-07-12T13:02:30.458Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --><p>JUC中的Exchanger允许<strong>成对的</strong>线程在指定的同步点上通过<code>exchange</code>方法来交换数据。如果第一个线程先执行<code>exchange</code>方法，它会一直等待第二个线程也 执行<code>exchange</code>方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将当前线程生产 出来的数据传递给对方。<a id="more"></a></p><h2 id="Exchanger示例"><a href="#Exchanger示例" class="headerlink" title="Exchanger示例"></a>Exchanger示例</h2><p>两个线程通过Exchanger交换数据的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread1开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread1的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收thread2发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread1结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread2的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收thread1发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread2结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在定义Exchanger的时候需要指定交换的数据类型，这里为String类型。<code>exchange</code>方法用于向另一个线程发送数据，方法的返回值为另一个线程发送过来的数据。上面例子输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line">接收thread2发送的数据：来自thread2的数据</span><br><span class="line">thread1结束</span><br><span class="line">接收thread1发送的数据：来自thread1的数据</span><br><span class="line">thread2结束</span><br></pre></td></tr></table></figure><p></p><p>上面说过，只有当成对的线程都到达同步点的时候，才会执行数据交换操作。现在我们让thread2休眠一会儿，看看thread1是否会进入等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread1开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread1的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收thread2发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread1结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>); <span class="comment">// thread1也会进入等待，直到双方都准备好交换数据。</span></span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread2的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收thread1发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread2结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下所示：</p><p><img src="img/exchanger1.gif" alt="exchanger1.gif"></p><p>那么如果线程不成对会出现什么情况呢？我们添加thread3线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread1开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"发送数据-thread1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread1结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"发送数据-thread2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread2结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread3开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"发送数据-thread3"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread3结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread3"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread3开始</span><br><span class="line">接收数据：发送数据-thread1</span><br><span class="line">thread3结束</span><br><span class="line">thread2开始</span><br><span class="line">接收数据：发送数据-thread3</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure><p></p><p>可看到thread1和thread3交换了数据然后正常停止了，而thread2由于没有线程和它交换数据而苦苦等待，线程永远不会停止。查看线程快照可以证明这点：</p><p><img src="img/QQ截图20190514092846.png" alt="QQ截图20190514092846.png"></p><p>线程匹配是随机的，所以也有可能thread1和thread2匹配，thread3进入无休止的等待，这就类似于…</p><p><img src="img/QQ截图20190514093233.png" alt="QQ截图20190514093233.png"></p><p>另一个值得一提的点就是通过Exchanger交换的是同一个对象，而不是对象的拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;Object&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread1开始"</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">"thread1发送数据："</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">"接收thread2发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread1结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2开始"</span>);</span><br><span class="line">            Object object = <span class="keyword">new</span> Object();</span><br><span class="line">            System.out.println(<span class="string">"thread2发送数据："</span> + object);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object exchange = exchanger.exchange(object);</span><br><span class="line">                System.out.println(<span class="string">"接收thread1发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread2结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread1开始</span><br><span class="line">thread2开始</span><br><span class="line">thread2发送数据：java.lang.Object@6d559005</span><br><span class="line">thread1发送数据：java.lang.Object@7702c19</span><br><span class="line">接收thread2发送的数据：java.lang.Object@6d559005</span><br><span class="line">接收thread1发送的数据：java.lang.Object@7702c19</span><br><span class="line">thread2结束</span><br><span class="line">thread1结束</span><br></pre></td></tr></table></figure><p></p><p>可以看到thread1发送的对象和thread2接收的对象句柄是一致的。</p><h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>如果不想线程在交换数据的时候等待过长的时间，我们可以使用<code>exchanger</code>的重载方法<code>exchange(V x, long timeout, TimeUnit unit)</code>来指定超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread1开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread1的数据"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">"接收thread2发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread1结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2开始"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                String exchange = exchanger.exchange(<span class="string">"来自thread2的数据"</span>);</span><br><span class="line">                System.out.println(<span class="string">"接收thread1发送的数据："</span> + exchange);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"thread2结束"</span>);</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子中，thread2休眠10秒后才开始交换数据，而thread1在等待5秒后没能成功交换数据就抛出<code>TimeoutException</code>异常了。10秒后由于没有线程再和thread2交换数据，所以thread2会一直等待：</p><p><img src="img/QQ截图20190514093752.png" alt="QQ截图20190514093752.png"></p><p><img src="img/QQ截图20190514093839.png" alt="QQ截图20190514093839.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;JUC中的Exchanger允许&lt;strong&gt;成对的&lt;/strong&gt;线程在指定的同步点上通过&lt;code&gt;exchange&lt;/code&gt;方法来交换数据。如果第一个线程先执行&lt;code&gt;exchange&lt;/code&gt;方法，它会一直等待第二个线程也 执行&lt;code&gt;exchange&lt;/code&gt;方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将当前线程生产 出来的数据传递给对方。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CyclicBarrier</title>
    <link href="http://mrbird.cc/JUC-CyclicBarrier.html"/>
    <id>http://mrbird.cc/JUC-CyclicBarrier.html</id>
    <published>2019-03-03T08:23:58.000Z</published>
    <updated>2019-07-12T13:02:30.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><a id="more"></a><h2 id="CyclicBarrier示例"><a href="#CyclicBarrier示例" class="headerlink" title="CyclicBarrier示例"></a>CyclicBarrier示例</h2><p>使用“人满发车”的例子来演示CyclicBarrier：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"快上车来不及解释了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"已上车"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">"所有人已上车，发车"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Jane"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"已上车"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">"所有人已上车，发车"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Mike"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子中我们定义了一个等待2个线程完成的CyclicBarrier，在两个线程内部调用了<code>await</code>方法，让其阻塞等待，并告知CyclicBarrier我已经到达屏障了。只有当两个线程都执行到<code>barrier.await()</code>这一行时，屏障开启，线程才会继续往下执行。程序输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line">Thread[Mike,5,main]已上车</span><br><span class="line">Thread[Jane,5,main]已上车</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure><p></p><p>CyclicBarrier的构造函数支持传入一个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(n, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"当所有线程到达屏障时，执行该回调"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>改造上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"发车，嘟嘟嘟"</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"快上车来不及解释了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"已上车"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">"所有人已上车"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Jane"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"已上车"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(<span class="string">"所有人已上车"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Mike"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">快上车来不及解释了</span><br><span class="line">Thread[Mike,5,main]已上车</span><br><span class="line">Thread[Jane,5,main]已上车</span><br><span class="line">发车，嘟嘟嘟</span><br><span class="line">所有人已上车，发车</span><br><span class="line">所有人已上车，发车</span><br></pre></td></tr></table></figure><p></p><h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p><code>await</code>的重载方法：<code>await(long timeout, TimeUnit unit)</code>可以设置最大等待时长，超出这个时间屏障还没有开启的话则抛出<code>TimeoutException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190513104938.png" alt="QQ截图20190513104938.png"></p><p><img src="img/QQ截图20190513105045.png" alt="QQ截图20190513105045.png"></p><h2 id="BrokenBarrierException"><a href="#BrokenBarrierException" class="headerlink" title="BrokenBarrierException"></a>BrokenBarrierException</h2><p>抛出<code>BrokenBarrierException</code>异常时表示屏障破损，此时标志位broken=true。抛出<code>BrokenBarrierException</code>异常的情况主要有：</p><ol><li><p>其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常；</p></li><li><p>其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常；</p></li><li><p>当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常。</p></li></ol><p>模拟第1种情况，其他等待的线程被中断，则当前线程抛出<code>BrokenBarrierException</code>异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>);</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p><img src="img/QQ截图20190513112642.png" alt="QQ截图20190513112642.png"></p><p>上面例子中thread2线程睡眠1秒后先到达屏障点，然后进入等待状态。2秒后main线程执行<code>thread2.interrupt()</code>中断等待中的thread2线程，所以程序抛出<code>BrokenBarrierException</code>异常。3秒后thread1线程到达屏障点，此时屏障已经被破坏了，所以也抛出<code>BrokenBarrierException</code>异常。</p><p>模拟第2钟情况：其他等待的线程超时，则当前线程抛出<code>BrokenBarrierException</code>异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p><img src="img/QQ截图20190513113514.png" alt="QQ截图20190513113514.png"></p><p>上面例子中thread2睡眠1秒后到达屏障点，然后进入等待状态（最多等待1秒），然而因为thread1要3秒后才能到达屏障点，所以thread2将抛出<code>TimeoutException</code>。3秒后，thread1到达屏障点，但这时候由于thread2的<code>await</code>方法抛出的异常破坏了屏障，所以thread1将抛出<code>BrokenBarrierException</code>异常。</p><p>模拟第3中情况：当前线程在等待时，其他线程调用CyclicBarrier.reset()方法，则当前线程抛出BrokenBarrierException异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"开始执行"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"继续执行"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread2"</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(barrier.getNumberWaiting());</span><br><span class="line">        barrier.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p><img src="img/QQ截图20190513114412.png" alt="QQ截图20190513114412.png"></p><p>上面例子中，thread2睡眠1秒后到达屏障点，然后进入等待状态。2秒后main线程调用<code>reset</code>方法重置了屏障，所以在等待状态中的thread2抛出<code>BrokenBarrierException</code>异常。3秒后，thread1到达屏障点，由于<code>reset</code>方法重置了屏障，所以thread1并不会抛出<code>BrokenBarrierException</code>异常，而是一直在屏障点进行等待别的线程到达屏障点。</p><p><strong>从上面的三个例子中可以看到，无论是哪种情况导致屏障破坏，屏障点后面的代码都没有被执行，main方法也没有退出。</strong></p><h2 id="和CountDownLatch区别"><a href="#和CountDownLatch区别" class="headerlink" title="和CountDownLatch区别"></a>和CountDownLatch区别</h2><ol><li><p>CountDownLatch：一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p></li><li><p>CountDownLatch：一次性的；CyclicBarrier：可以重复使用。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是&lt;code&gt;CyclicBarrier(int parties)&lt;/code&gt;，其参数表示屏障拦截的线程数量，每个线程调用&lt;code&gt;await&lt;/code&gt;方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CountDownLatch</title>
    <link href="http://mrbird.cc/JUC-CountDownLatch.html"/>
    <id>http://mrbird.cc/JUC-CountDownLatch.html</id>
    <published>2019-02-28T08:23:26.000Z</published>
    <updated>2019-07-12T13:02:30.456Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。定义CountDownLatch的时候，需要传入一个正数来初始化计数器（虽然传入0也可以，但这样的话CountDownLatch没什么实际意义）。其<code>countDown</code>方法用于递减计数器，<code>await</code>方法会使当前线程阻塞，直到计数器递减为0。所以CountDownLatch常用于多个线程之间的协调工作。<a id="more"></a></p><h2 id="CountDownLatch示例"><a href="#CountDownLatch示例" class="headerlink" title="CountDownLatch示例"></a>CountDownLatch示例</h2><p>假设我们现在有这样一个需求：</p><ol><li><p>从数据库获取数据</p></li><li><p>对这批数据进行处理</p></li><li><p>保存这批数据</p></li></ol><p>为了让程序执行效率更高，第2步中我们可以使用多线程来并行处理这批数据，大致过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">"获取数据完毕"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"处理第"</span> + (i + <span class="number">1</span>) + <span class="string">"条数据"</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"所有数据都处理完了"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据 - "</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于线程获取CPU时间片的不确定性，所以有可能数据还没有处理完毕，第3步就执行完了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">Thread[pool-1-thread-2,5,main]处理第2条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第1条数据</span><br><span class="line">Thread[pool-1-thread-2,5,main]处理第3条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第4条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第6条数据</span><br><span class="line">Thread[pool-1-thread-2,5,main]处理第5条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第7条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第9条数据</span><br><span class="line">Thread[pool-1-thread-2,5,main]处理第8条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第10条数据</span><br></pre></td></tr></table></figure><p></p><p>我们可以借助CountDownLatch解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService ExecutorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 模拟从数据库获取数据</span></span><br><span class="line">        <span class="keyword">int</span>[] data = query();</span><br><span class="line">        System.out.println(<span class="string">"获取数据完毕"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 数据处理</span></span><br><span class="line">        IntStream.range(<span class="number">0</span>, data.length).forEach(i -&gt; &#123;</span><br><span class="line">            ExecutorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"处理第"</span> + (i + <span class="number">1</span>) + <span class="string">"条数据"</span>);</span><br><span class="line">                <span class="keyword">int</span> value = data[i];</span><br><span class="line">                <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    data[i] = value * <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data[i] = value * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">"所有数据都处理完了"</span>);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        ExecutorService.shutdown();</span><br><span class="line">        <span class="comment">// 3. 保存数据</span></span><br><span class="line">        save(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] query() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据 - "</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们定义了一个CountDownLatch，计数器值为10，和数据量一致。然后在第2步中，当每个线程执行完毕的时候调用<code>countDown</code>方法，让计数器减1。在第3步前调用<code>await</code>方法让main线程阻塞等待，直到计数器被减为0。所以这就保证了只有当所有数据加工完毕才执行保存数据操作。</p><p>执行方法，程序输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">获取数据完毕</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第1条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第3条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第4条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第5条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第6条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第7条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第8条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第9条数据</span><br><span class="line">Thread[pool-1-thread-1,5,main]处理第10条数据</span><br><span class="line">Thread[pool-1-thread-2,5,main]处理第2条数据</span><br><span class="line">所有数据都处理完了</span><br><span class="line">保存数据 - [10, 4, 30, 8, 50, 12, 70, 16, 90, 20]</span><br></pre></td></tr></table></figure><p></p><p><code>await</code>有重载方法：<code>await(long timeout, TimeUnit unit)</code>，设置最大等待时间，超过这个时间程序将继续执行不再被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"线程执行完毕"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line"> </span><br><span class="line">        latch.await(<span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 最多等待 3秒</span></span><br><span class="line">        System.out.println(<span class="string">"main线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main线程执行完毕</span><br><span class="line">Thread[thread1,5,main]线程执行完毕</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;CountDownLatch允许一个或多个线程等待其他线程完成操作。定义CountDownLatch的时候，需要传入一个正数来初始化计数器（虽然传入0也可以，但这样的话CountDownLatch没什么实际意义）。其&lt;code&gt;countDown&lt;/code&gt;方法用于递减计数器，&lt;code&gt;await&lt;/code&gt;方法会使当前线程阻塞，直到计数器递减为0。所以CountDownLatch常用于多个线程之间的协调工作。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="http://mrbird.cc/Java-Memory-model.html"/>
    <id>http://mrbird.cc/Java-Memory-model.html</id>
    <published>2019-02-25T07:15:03.000Z</published>
    <updated>2019-07-12T13:02:30.463Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>理解Java内存模型是深入学习Java并发不可或缺的部分。Java内存模型即Java Memory Model，简称为JMM，定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。</p><p>JMM规定Java线程间的通信采用共享内存的方式。在Java中，所有成员变量、静态变量和数组元素都存储在堆内存中，堆内存在线程之间共享，所以它们通常也称为共享变量。JMM定义了线程和主内存之间的抽 象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory，或者也可以称为工作内存 Work Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><a id="more"></a><h2 id="JMM抽象"><a href="#JMM抽象" class="headerlink" title="JMM抽象"></a>JMM抽象</h2><p>JMM的抽象示意图如下所示：</p><p><img src="img/QQ截图20190513142140.png" alt="QQ截图20190513142140.png"></p><p>多个线程同时对同一个共享变量进行读写的时候会产生线程安全问题。那为什么CPU不直接操作内存，而要在CPU和内存间加上各种缓存和寄存器等缓冲区呢？因为CPU的运算速度要比内存的读写速度快得多，如果CPU直接操作内存的话势必会花费很长时间等待数据到来，所以缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾。</p><h2 id="内存间交互协议"><a href="#内存间交互协议" class="headerlink" title="内存间交互协议"></a>内存间交互协议</h2><p>JMM规定了主内存和工作内存间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，这主要包含了下面8个步骤：</p><p><img src="img/QQ截图20190513144649.png" alt="QQ截图20190513144649.png"></p><ul><li><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p></li><li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p></li><li><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p></li><li><p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p></li><li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p></li><li><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p></li><li><p>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p></li></ul><p>这8个步骤必须符合下述规则：</p><ol><li><p>不允许read和load，store和write操作之一单独出现。</p></li><li><p>不允许一个线程丢弃它最近的assign操作。即变量在工作内存中改变了账号必须把变化同步回主内存</p></li><li><p>一个新的变量只允许在主内存中诞生，不允许工作内存直接使用未初始化的变量。</p></li><li><p>一个变量同一时刻只允许一条线程进行lock操作，但同一线程可以lock多次，lock多次之后必须执行同样次数的unlock操作</p></li><li><p>如果对一个变量进行lock操作，那么将会清空工作内存中此变量的值。</p></li><li><p>不允许对未lock的变量进行unlock操作，也不允许unlock一个被其它线程lock的变量</p></li><li><p>如果一个变量执行unlock操作，必须先把此变量同步回主内存中。</p></li></ol><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序：</p><ol><li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>通过插入内存屏障（Memory Barrier）可以阻止特定类型的指令重排。JMM将内存屏障划分为四种：</p><table><tr><th>屏障类型</th><th>示例</th><th>描述</th></tr><tr><td>LoadLoad Barriers</td><td>Load1-LoadLoad-Load2</td><td>Load1数据装载过程要先于Load2及所有后续的数据装载过程</td></tr><tr><td>StoreStore Barriers</td><td>Store1-StoreStore-Store2</td><td>Store1刷新数据到内存的过程要先于Strore2及后续所有刷新数据到内存的过程</td></tr><tr><td>LoadStore Barriers</td><td>Load1-LoadStore-Store2</td><td>Load1数据装载要先于Strore2及后续所有刷新数据到内存的过程</td></tr><tr><td>StoreLoad Barriers</td><td>Store1-StoreLoad-Load2</td><td>Store1刷新数据到内存的过程要先于Load2及所有后续的数据装载过程</td></tr></table><p>Java中volatile关键字的实现就是通过内存屏障来完成的。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。</p><p>在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。</p><p>与程序员密切相关的happens-before规则如下：</p><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。</p></li><li><p>监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。</p></li><li><p>volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。</p></li><li><p>传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。</p></li></ul><div class="note danger"><p>注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。</p></div><blockquote><p>参考自：<a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">Java并发编程的艺术</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;理解Java内存模型是深入学习Java并发不可或缺的部分。Java内存模型即Java Memory Model，简称为JMM，定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。&lt;/p&gt;&lt;p&gt;JMM规定Java线程间的通信采用共享内存的方式。在Java中，所有成员变量、静态变量和数组元素都存储在堆内存中，堆内存在线程之间共享，所以它们通常也称为共享变量。JMM定义了线程和主内存之间的抽 象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory，或者也可以称为工作内存 Work Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Guava 杂项笔记</title>
    <link href="http://mrbird.cc/Guava-Miscellaneous-notes.html"/>
    <id>http://mrbird.cc/Guava-Miscellaneous-notes.html</id>
    <published>2019-01-18T01:41:24.000Z</published>
    <updated>2019-07-12T13:02:30.451Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>这里主要记录Guava提供的一些工具类的用法。</p><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>空和null相互转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = Strings.emptyToNull(<span class="string">""</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// null</span></span><br><span class="line">String s2 = Strings.nullToEmpty(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(s2); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>获取相同的前缀和后缀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s3 = Strings.commonPrefix(<span class="string">"mrbird"</span>, <span class="string">"mr.right"</span>);</span><br><span class="line">System.out.println(s3); <span class="comment">// mr</span></span><br><span class="line">String s4 = Strings.commonSuffix(<span class="string">"mrbird"</span>, <span class="string">"third"</span>);</span><br><span class="line">System.out.println(s4); <span class="comment">// ird</span></span><br></pre></td></tr></table></figure><p></p><p>repeat重复操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s5 = Strings.repeat(<span class="string">"mrbird"</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(s5); <span class="comment">// mrbirdmrbirdmrbird</span></span><br></pre></td></tr></table></figure><p></p><p>判断字符串是否为空或null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> nullOrEmpty = Strings.isNullOrEmpty(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(nullOrEmpty); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><p>左侧填充和右侧填充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s6 = Strings.padStart(<span class="string">"01"</span>, <span class="number">5</span>, <span class="string">'0'</span>);</span><br><span class="line">System.out.println(s6); <span class="comment">// 00001</span></span><br><span class="line">String s7 = Strings.padEnd(<span class="string">"1.0"</span>, <span class="number">5</span>, <span class="string">'0'</span>);</span><br><span class="line">System.out.println(s7); <span class="comment">// 1.000</span></span><br></pre></td></tr></table></figure><p></p><h2 id="StopWatcher"><a href="#StopWatcher" class="headerlink" title="StopWatcher"></a>StopWatcher</h2><p>StopWatcher用于监测一段程序的执行耗时。我们之前通常的做法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"程序开始处理"</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"程序处理结束，耗时"</span> + (System.currentTimeMillis() - start) + <span class="string">"毫秒"</span>); <span class="comment">// 程序处理结束，耗时2.002 s</span></span><br></pre></td></tr></table></figure><p></p><p>使用StopWatcher方便之处在于它会帮我们选取合适的时间单位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"程序开始处理"</span>);</span><br><span class="line">Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"程序处理结束，耗时"</span> + stopwatch.stop()); <span class="comment">// 程序处理结束，耗时2.002 s</span></span><br></pre></td></tr></table></figure><p></p><h2 id="Preconditions断言"><a href="#Preconditions断言" class="headerlink" title="Preconditions断言"></a>Preconditions断言</h2><p>断言常用于类库设计中方法参数的判断，当参数不符合要求时，让程序提前抛异常结束。Preconditions是Guava提供的断言类。</p><h3 id="非空校验"><a href="#非空校验" class="headerlink" title="非空校验"></a>非空校验</h3><p>判断是否为空，为空的话抛出<code>NullPointerException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">Preconditions.checkNotNull(list);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505140513.png" alt="QQ截图20190505140513.png"></p><p>自定义描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">Preconditions.checkNotNull(list, <span class="string">"list不能为空"</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505140642.png" alt="QQ截图20190505140642.png"></p><p>自定义描述 + 长度校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">Preconditions.checkNotNull(list, <span class="string">"list长度必须为%s"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505140741.png" alt="QQ截图20190505140741.png"></p><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>校验不通过时，抛出<code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="string">"hello"</span>;</span><br><span class="line">Preconditions.checkArgument(<span class="string">"world"</span>.equals(value), <span class="string">"参数内容必须为world"</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505140953.png" alt="QQ截图20190505140953.png"></p><h3 id="状态校验"><a href="#状态校验" class="headerlink" title="状态校验"></a>状态校验</h3><p>校验不通过时，抛出<code>IllegalStateException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String state = <span class="string">"on"</span>;</span><br><span class="line">Preconditions.checkState(<span class="string">"off"</span>.equals(state), <span class="string">"状态必须为off"</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505141058.png" alt="QQ截图20190505141058.png"></p><h3 id="校验元素个数"><a href="#校验元素个数" class="headerlink" title="校验元素个数"></a>校验元素个数</h3><p>校验不通过，抛出<code>IndexOutOfBoundsException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of();</span><br><span class="line">Preconditions.checkElementIndex(<span class="number">10</span>, list.size(), <span class="string">"下标越界，不存在第10个元素"</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505141210.png" alt="QQ截图20190505141210.png"></p><h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>演示之前先创建一个source.txt文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Guava I/O operation</span><br><span class="line">Guava I/O 操作</span><br></pre></td></tr></table></figure><p></p><p>相关常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SOURCE_FILE = <span class="string">"C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\source.txt"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TARGET_FILE = <span class="string">"C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\target.txt"</span>;</span><br></pre></td></tr></table></figure><p></p><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File targetFile = <span class="keyword">new</span> File(TARGET_FILE);</span><br><span class="line">Files.copy(<span class="keyword">new</span> File(SOURCE_FILE), targetFile);</span><br><span class="line">System.out.println(targetFile.exists()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="img/QQ截图20190505141800.png" alt="QQ截图20190505141800.png"></p><h3 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.move(<span class="keyword">new</span> File(SOURCE_FILE), <span class="keyword">new</span> File(TARGET_FILE));</span><br></pre></td></tr></table></figure><p>文件移动和文件拷贝的区别是，文件移动会删除源文件：</p><p><img src="img/QQ截图20190505142008.png" alt="QQ截图20190505142008.png"></p><h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>将文件内容读取到String集合中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Files.readLines(<span class="keyword">new</span> File(SOURCE_FILE), Charsets.UTF_8);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505142229.png" alt="QQ截图20190505142229.png"></p><p>读的过程中进行一些加工：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LineProcessor&lt;List&lt;String&gt;&gt; lineProcessor = <span class="keyword">new</span> LineProcessor&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    List&lt;String&gt; result = Lists.newArrayList();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processLine</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (line.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(line + <span class="string">"。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; result = Files.asCharSource(<span class="keyword">new</span> File(SOURCE_FILE), Charsets.UTF_8).readLines(lineProcessor);</span><br><span class="line">System.out.println(result); <span class="comment">// [Guava I/O operation。, Guava I/O 操作。]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p>追加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(SOURCE_FILE);</span><br><span class="line">String value = <span class="string">"添加一些内容"</span>;</span><br><span class="line">CharSink charSink = Files.asCharSink(file, Charsets.UTF_8, FileWriteMode.APPEND); <span class="comment">// 追加</span></span><br><span class="line">charSink.write(value);</span><br><span class="line"></span><br><span class="line">String read = Files.asCharSource(file, Charsets.UTF_8).read();</span><br><span class="line">System.out.println(read);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505142616.png" alt="QQ截图20190505142616.png"></p><p>覆盖操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(SOURCE_FILE);</span><br><span class="line">String value = <span class="string">"添加一些内容"</span>;</span><br><span class="line">CharSink charSink = Files.asCharSink(file, Charsets.UTF_8); <span class="comment">// 覆盖</span></span><br><span class="line">charSink.write(value);</span><br><span class="line"></span><br><span class="line">String read = Files.asCharSource(file, Charsets.UTF_8).read();</span><br><span class="line">System.out.println(read);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505142740.png" alt="QQ截图20190505142740.png"></p><h3 id="文件转为哈希码"><a href="#文件转为哈希码" class="headerlink" title="文件转为哈希码"></a>文件转为哈希码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(SOURCE_FILE);</span><br><span class="line">HashCode hash = Files.asByteSource(file).hash(Hashing.sha256());</span><br><span class="line">System.out.println(hash); <span class="comment">// c46982603d4b2ba5032d73dc1fffbe1aea1f11d75921b2839632c56636673d31</span></span><br></pre></td></tr></table></figure><h3 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String TOUCH_FILE = <span class="string">"C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird\\resources\\new.txt"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(TOUCH_FILE);</span><br><span class="line">Files.touch(file);</span><br><span class="line"><span class="keyword">boolean</span> exists = file.exists();</span><br><span class="line">System.out.println(exists); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="递归操作"><a href="#递归操作" class="headerlink" title="递归操作"></a>递归操作</h3><p>由浅入深：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird"</span>);</span><br><span class="line"><span class="comment">// depthFirstPreOrder 由浅入深</span></span><br><span class="line">Iterable&lt;File&gt; files = Files.fileTraverser().depthFirstPreOrder(file);</span><br><span class="line">files.forEach(f -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"directory: "</span> + f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"file: "</span> + f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505143344.png" alt="QQ截图20190505143344.png"></p><p>由深入浅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\Administrator\\Desktop\\guavatest\\src\\test\\java\\cc\\mrbird"</span>);</span><br><span class="line"><span class="comment">// depthFirstPostOrder 由深入浅</span></span><br><span class="line">Iterable&lt;File&gt; files = Files.fileTraverser().depthFirstPostOrder(file);</span><br><span class="line">files.forEach(f -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"directory: "</span> + f);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"file: "</span> + f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190505143508.png" alt="QQ截图20190505143508.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这里主要记录Guava提供的一些工具类的用法。&lt;/p&gt;&lt;h2 id=&quot;Strings&quot;&gt;&lt;a href=&quot;#Strings&quot; class=&quot;headerlink&quot; title=&quot;Strings&quot;&gt;&lt;/a&gt;Strings&lt;/h2&gt;&lt;p&gt;空和null相互转换：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String s1 = Strings.emptyToNull(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(s1); &lt;span class=&quot;comment&quot;&gt;// null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String s2 = Strings.nullToEmpty(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(s2); &lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="guava" scheme="http://mrbird.cc/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Guava RateLimiter</title>
    <link href="http://mrbird.cc/Guava-RateLimiter.html"/>
    <id>http://mrbird.cc/Guava-RateLimiter.html</id>
    <published>2019-01-15T01:38:42.000Z</published>
    <updated>2019-07-12T13:02:30.452Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>Google Guava提供的<code>RateLimiter</code>使用的是令牌桶算法。令牌桶算法的基本思想是以固定的速率生成令牌，在执行请求之前都需要从令牌桶里获取足够的令牌。当令牌数量不足的时候，请求将被阻塞进入等待状态或者直接返回失败。<code>RateLimiter</code>常用于限制访问资源的速率。<a id="more"></a></p><h2 id="RateLimiter使用示例"><a href="#RateLimiter使用示例" class="headerlink" title="RateLimiter使用示例"></a>RateLimiter使用示例</h2><p>下面是一个RateLimiter的简单使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1秒钟产生0.5张令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> RateLimiter limiter = RateLimiter.create(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt; service.submit(RateLimiterTest::testLimiter));</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">" waiting "</span> + limiter.acquire());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们定义了一个<code>RateLimiter</code>实例，每秒钟产生0.5张令牌，即每2秒钟产生1张令牌。<code>testLimiter</code>方法中通过<code>limiter.acquire()</code>方法获取令牌（不带参数时默认获取1张令牌）。<code>Executors.newFixedThreadPool(5)</code>生成五个线程，并发调用<code>testLimiter</code>方法，执行代码，控制台输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-1,5,main] waiting 0.0</span><br><span class="line">Thread[pool-1-thread-5,5,main] waiting 1.908947</span><br><span class="line">Thread[pool-1-thread-4,5,main] waiting 3.908935</span><br><span class="line">Thread[pool-1-thread-3,5,main] waiting 5.908919</span><br><span class="line">Thread[pool-1-thread-2,5,main] waiting 7.908808</span><br></pre></td></tr></table></figure><p>可以看到每个线程调用时间相隔大约为2秒钟。可能你会问，为什么第一个线程没有等待2秒，直接就获取到了令牌然后执行了呢？</p><p>Guava RateLimiter允许某次请求获取超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上。再来看一个<code>RateLimiter</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">4</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">2</span>));</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">3.996602</span><br><span class="line">2.997448</span><br><span class="line">2.000229</span><br></pre></td></tr></table></figure><p></p><p>上面例子钟，一秒钟产生一张令牌，第一次请求直接取出4张令牌，所以第二次请求需要等待4/1秒才能取到令牌。经过大约4秒后，第二次请求直接取出3张令牌，所以第三次请求需要等待3/1秒后才能取到令牌，依此类推。</p><h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><p>我们可以设置等待令牌的超时时间，如果等待令牌的时间大于超时时间，将直接返回false，不再等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RateLimiter limiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        System.out.println(limiter.acquire(<span class="number">3</span>));</span><br><span class="line">        System.out.println(limiter.tryAcquire(<span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面例子<code>limiter.tryAcquire</code>设置了超时时间为2秒，由于第一次请求一次性获取了3张令牌，所以这里需要等待大约3秒钟，超出了2秒的超时时间，所以<code>limiter.tryAcquire</code>不会等待3秒，而是直接返回false。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Google Guava提供的&lt;code&gt;RateLimiter&lt;/code&gt;使用的是令牌桶算法。令牌桶算法的基本思想是以固定的速率生成令牌，在执行请求之前都需要从令牌桶里获取足够的令牌。当令牌数量不足的时候，请求将被阻塞进入等待状态或者直接返回失败。&lt;code&gt;RateLimiter&lt;/code&gt;常用于限制访问资源的速率。
    
    </summary>
    
    
      <category term="guava" scheme="http://mrbird.cc/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Guava 缓存</title>
    <link href="http://mrbird.cc/Guava-Cache.html"/>
    <id>http://mrbird.cc/Guava-Cache.html</id>
    <published>2019-01-07T02:11:26.000Z</published>
    <updated>2019-07-12T13:02:30.450Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --><p>Guava缓存是轻量级的，它将内容缓存到运行内存中。如果系统中某些值（比如一些配置表）被频繁查询使用，并且我们愿意消耗一些内存空间来提升应用的速度，减轻数据库压力的话，Guava缓存将会是一个不错的选择。由于缓存是存储在运行内存中的，所以我们需要确保缓存的大小不超出内存的容量。<a id="more"></a></p><h2 id="创建缓存"><a href="#创建缓存" class="headerlink" title="创建缓存"></a>创建缓存</h2><p>我们可以直接创建Guava缓存对象，而不使用任何的CacheLoader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"hello"</span>)); <span class="comment">//  world</span></span><br></pre></td></tr></table></figure><p></p><p>key值是大小写敏感的，所以使用<code>cache.getIfPresent(&quot;HELLO&quot;)</code>将返回null值。</p><p>接下来看看如何使用CacheLoader创建缓存对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CacheLoader&lt;String, String&gt; loader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build(loader);</span><br><span class="line"></span><br><span class="line">String mrbird = cache.getUnchecked(<span class="string">"mrbird"</span>);</span><br><span class="line">System.out.println(mrbird); <span class="comment">// hello mrbird</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"hello %s"</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方法<code>getUnchecked</code>作用为：当值不存在时，会通过CacheLoader计算出值，然后存到缓存中。</p><h2 id="驱逐机制"><a href="#驱逐机制" class="headerlink" title="驱逐机制"></a>驱逐机制</h2><p>我们可以定义一些驱逐缓存的机制来限制缓存的大小。</p><h3 id="限制缓存数目"><a href="#限制缓存数目" class="headerlink" title="限制缓存数目"></a>限制缓存数目</h3><p>我们可以通过<code>maximumSize</code>来限制缓存的条目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(<span class="number">3</span>).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">cache.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">cache.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line">cache.put(<span class="string">"k4"</span>, <span class="string">"v4"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k1"</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k4=v4, k2=v2&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>我们限制最多只能存储3个值，所以k4的存入把最早的k1给驱逐出去了，类似于FIFO。</p><h3 id="限制缓存大小"><a href="#限制缓存大小" class="headerlink" title="限制缓存大小"></a>限制缓存大小</h3><p>我们可以自定义权重函数来限制缓存的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Weigher&lt;String, String&gt; weigher = (key, value) -&gt; value.length();</span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumWeight(<span class="number">15</span>).weigher(weigher).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"k1"</span>, <span class="string">"11111"</span>);</span><br><span class="line">cache.put(<span class="string">"k2"</span>, <span class="string">"22222"</span>);</span><br><span class="line">cache.put(<span class="string">"k3"</span>, <span class="string">"33333"</span>);</span><br><span class="line">cache.put(<span class="string">"k4"</span>, <span class="string">"4444"</span>);</span><br><span class="line">cache.put(<span class="string">"k5"</span>, <span class="string">"5555"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k1"</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=33333, k5=5555, k4=4444&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>上面例子中，我们通过<code>maximumWeight(15)</code>指定了缓存的最大容量，权重规则为value的长度。k3，k4和k5的value长度加起来为13，所以k1和k2的值存不小了，被驱逐。</p><h3 id="设置缓存时间"><a href="#设置缓存时间" class="headerlink" title="设置缓存时间"></a>设置缓存时间</h3><p>我们可以设置缓存的有效时间和缓存的活跃时间。</p><p>设置缓存的活跃时间为2s：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterAccess(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">cache.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">"k1"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">"k1"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k1"</span>)); <span class="comment">// v1</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k2"</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>上面代码中，我们通过<code>cache.getIfPresent(&quot;k1&quot;)</code>获取了k1的值，然后让线程阻塞1秒，这时候k1和k2的有效时间大约为1秒左右。接着又获取了k1的值，所以k1的有效时间还是2秒，k2为1秒，再次让线程阻塞1秒后，k1的有效时间为1秒，k2已经失效了。打印输出的结果和我们预期的一致。</p><p>设置缓存的有效时间为2s：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS).build();</span><br><span class="line"></span><br><span class="line">cache.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">cache.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line"></span><br><span class="line">cache.getIfPresent(<span class="string">"k1"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">cache.getIfPresent(<span class="string">"k1"</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k1"</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.getIfPresent(<span class="string">"k2"</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>因为我们设置缓存有效时间为2秒，所以2秒后所有缓存都过期失效了，无论期间获取过多少次缓存。</p><h3 id="weakKeys-amp-softValues"><a href="#weakKeys-amp-softValues" class="headerlink" title="weakKeys&amp;softValues"></a>weakKeys&amp;softValues</h3><p>默认情况下，Guava缓存键值都有强引用，我们可以使用weakKeys和softValues来让键值变为弱引用，这样垃圾收集器在必要的情况下将会工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().weakKeys().softValues().build();</span><br></pre></td></tr></table></figure><p></p><h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><p>可以通过<code>refreshAfterWrite</code>设置缓存自动刷新间隔，或者可以直接调用<code>refresh</code>方法来手动刷新缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().refreshAfterWrite(<span class="number">1</span>,TimeUnit.SECONDS).build();</span><br></pre></td></tr></table></figure><p></p><h2 id="添加多个缓存"><a href="#添加多个缓存" class="headerlink" title="添加多个缓存"></a>添加多个缓存</h2><p>可以通过<code>putAll</code>来一次性添加多个缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">map.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">map.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line"></span><br><span class="line">cache.putAll(map);</span><br><span class="line">System.out.println(cache.size()); <span class="comment">// 3</span></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k3=v3, k1=v1, k2=v2&#125;</span></span><br></pre></td></tr></table></figure><p></p><h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p><code>Cache.invalidate(key)</code>方法通过key来删除缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().build();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">cache.putAll(map);</span><br><span class="line"></span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;k1=v1&#125;</span></span><br><span class="line">cache.invalidate(<span class="string">"k1"</span>);</span><br><span class="line">System.out.println(cache.asMap()); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>除此之外，我们也可以通过<code>Cache.invalidateAll(keys)</code>一次性删除多个缓存或者<code>Cache.invalidateAll()</code>删除全部缓存。</p><p>我们还可以给删除事件添加监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = notification -&gt; System.out.println(<span class="string">"监听到删除事件，key="</span> + notification.getKey() + <span class="string">"，value="</span> + notification.getValue());</span><br><span class="line"></span><br><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().removalListener(listener).build();</span><br><span class="line">cache.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line"></span><br><span class="line">cache.invalidate(<span class="string">"k1"</span>); <span class="comment">// 监听到删除事件，key=k1，value=v1</span></span><br></pre></td></tr></table></figure><p></p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>简单封装一个Guava缓存工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaCacheUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(GuavaCacheUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cache&lt;String, String&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RemovalListener&lt;String, String&gt; listener</span><br><span class="line">                = n -&gt; logger.info(<span class="string">"监听到删除事件，key=&#123;&#125;，value=&#123;&#125;"</span>, n.getKey(), n.getValue());</span><br><span class="line">        cache = CacheBuilder.newBuilder()</span><br><span class="line">                .removalListener(listener).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key) &amp;&amp; StringUtils.isNotBlank(value)) &#123;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量添加缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map key,value集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        cache.putAll(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(key)) &#123;</span><br><span class="line">            cache.invalidate(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys key集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(keys)) &#123;</span><br><span class="line">            cache.invalidateAll(keys);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cache.invalidateAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.isNotBlank(key) ? cache.getIfPresent(key) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量获取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys 键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableMap&lt;String, String&gt; <span class="title">get</span><span class="params">(List&lt;String&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isNotEmpty(keys) ? cache.getAllPresent(keys) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:13 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Guava缓存是轻量级的，它将内容缓存到运行内存中。如果系统中某些值（比如一些配置表）被频繁查询使用，并且我们愿意消耗一些内存空间来提升应用的速度，减轻数据库压力的话，Guava缓存将会是一个不错的选择。由于缓存是存储在运行内存中的，所以我们需要确保缓存的大小不超出内存的容量。
    
    </summary>
    
    
      <category term="guava" scheme="http://mrbird.cc/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>Guava 集合操作</title>
    <link href="http://mrbird.cc/Guava-Collection.html"/>
    <id>http://mrbird.cc/Guava-Collection.html</id>
    <published>2019-01-05T06:05:25.000Z</published>
    <updated>2019-07-12T13:02:30.451Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><p>不可变集合例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutableSet&lt;String&gt; FRUITS = ImmutableSet.of(<span class="string">"apple"</span>, <span class="string">"watermelon"</span>, <span class="string">"cherry"</span>, <span class="string">"mango"</span>);</span><br><span class="line">FRUITS.remove(<span class="string">"apple"</span>);</span><br></pre></td></tr></table></figure><p></p><p>将抛出<code>java.lang.UnsupportedOperationException</code>异常：<a id="more"></a> <img src="img/febsvue/QQ截图20190422144849.png" alt="QQ截图20190422144849.png"></p><h3 id="创建不可变集合"><a href="#创建不可变集合" class="headerlink" title="创建不可变集合"></a>创建不可变集合</h3><p><strong>of</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">ImmutableMap&lt;Integer, String&gt; immutableMap = ImmutableMap.of(<span class="number">1</span>, <span class="string">"v1"</span>, <span class="number">2</span>, <span class="string">"v2"</span>, <span class="number">3</span>, <span class="string">"v3"</span>)</span><br></pre></td></tr></table></figure><p></p><p><strong>copyOf</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">ImmutableMap&lt;String, String&gt; immutableMap = ImmutableMap.copyOf(map);</span><br></pre></td></tr></table></figure><p></p><p><strong>builder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line">ImmutableMap&lt;String, String&gt; immutableMap = ImmutableMap.&lt;String, String&gt;builder()</span><br><span class="line">                .putAll(map)</span><br><span class="line">                .put(<span class="string">"k1"</span>, <span class="string">"v1"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.&lt;String&gt;builder()</span><br><span class="line">                .addAll(list)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p></p><p>除此之外，我们也可以从Java 8 Stream中创建不可变集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; immutableList = list.stream()</span><br><span class="line">        .collect(collectingAndThen(toList(), ImmutableList::copyOf));</span><br><span class="line"></span><br><span class="line">System.out.println(immutableList.getClass()); <span class="comment">// class com.google.common.collect.RegularImmutableList</span></span><br></pre></td></tr></table></figure><p></p><p>上面的例子我们也可以使用Guava提供的收集器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; immutableList = list.stream()</span><br><span class="line">        .collect(ImmutableList.toImmutableList());</span><br><span class="line"></span><br><span class="line">System.out.println(immutableList.getClass()); <span class="comment">// class com.google.common.collect.RegularImmutableList</span></span><br></pre></td></tr></table></figure><p></p><h3 id="不可变集合优点"><a href="#不可变集合优点" class="headerlink" title="不可变集合优点"></a>不可变集合优点</h3><ol><li><p>当对象被不可信的库调用时，不可变形式是安全的；</p></li><li><p>不可变对象被多个线程调用时，不存在竞态条件问题</p></li><li><p>不可变集合不需要考虑变化，因此可以节省时间和空间。所有不可变的集合都比它们的可变形式有更好的内存利用率（分析和测试细节）；</p></li><li><p>不可变对象因为有固定不变，可以作为常量来安全使用。</p></li></ol><h2 id="新集合类型"><a href="#新集合类型" class="headerlink" title="新集合类型"></a>新集合类型</h2><p>Guava提供了许多JDK没有的集合类型。</p><h3 id="RangeSet"><a href="#RangeSet" class="headerlink" title="RangeSet"></a>RangeSet</h3><p>RangeSet一组不相连的、非空的区间，基本实现为TreeRangeSet，看个RangeSet的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();</span><br><span class="line">rangeSet.add(Range.closed(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">System.out.println(rangeSet); <span class="comment">// [[1..10]]</span></span><br><span class="line"></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">11</span>, <span class="number">15</span>));</span><br><span class="line">System.out.println(rangeSet); <span class="comment">// 不相连区间 [[1..10], [11..15)]</span></span><br><span class="line"></span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">15</span>, <span class="number">20</span>));</span><br><span class="line">System.out.println(rangeSet); <span class="comment">// 相连区间 [[1..10], [11..20)]</span></span><br><span class="line"></span><br><span class="line">rangeSet.add(Range.openClosed(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">System.out.println(rangeSet); <span class="comment">// 空区间 [[1..10], [11..20)]</span></span><br><span class="line"></span><br><span class="line">rangeSet.remove(Range.open(<span class="number">5</span>, <span class="number">10</span>)); </span><br><span class="line">System.out.println(rangeSet); <span class="comment">// 区间分割 [[1..5], [10..10], [11..20)]</span></span><br></pre></td></tr></table></figure><p></p><p>查看RangeSet的范围跨度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();</span><br><span class="line">rangeSet.add(Range.closed(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">rangeSet.add(Range.closedOpen(<span class="number">11</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">Range&lt;Integer&gt; span = rangeSet.span();</span><br><span class="line">System.out.println(span.lowerEndpoint().intValue()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(span.upperEndpoint().intValue()); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p></p><p>从已有的RangeSet获取一个子范围RangeSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">5</span>, <span class="number">8</span>));</span><br><span class="line">RangeSet&lt;Integer&gt; numberSubRangeSet = numberRangeSet.subRangeSet(Range.closed(<span class="number">4</span>, <span class="number">14</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(numberRangeSet); <span class="comment">// [[0..2], [3..8]]</span></span><br><span class="line">System.out.println(numberSubRangeSet); <span class="comment">// [[4..8]]</span></span><br></pre></td></tr></table></figure><p></p><p>获取除了RangeSet范围外的RangeSet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">6</span>, <span class="number">8</span>));</span><br><span class="line">RangeSet&lt;Integer&gt; numberRangeComplementSet = numberRangeSet.complement();</span><br><span class="line"></span><br><span class="line">System.out.println(numberRangeSet); <span class="comment">// [[0..2], [3..5], [6..8]]</span></span><br><span class="line">System.out.println(numberRangeComplementSet); <span class="comment">// [(-∞..0), (2..3), (5..6), (8..+∞)]</span></span><br></pre></td></tr></table></figure><p></p><p>判断一个RangeSet是否和另一个范围有交集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">15</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(numberRangeSet); <span class="comment">// [[0..2], [3..10], [15..18]]</span></span><br><span class="line">System.out.println(numberRangeSet.intersects(Range.closed(<span class="number">4</span>, <span class="number">17</span>))); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><p>遍历RangeSet的范围区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">15</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;Range&lt;Integer&gt;&gt; ranges = numberRangeSet.asRanges();</span><br><span class="line">ranges.forEach(System.out::print); <span class="comment">// [0..2][3..10][15..18]</span></span><br></pre></td></tr></table></figure><p></p><p>从RangeSet中获取包含某个值的访问区间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RangeSet&lt;Integer&gt; numberRangeSet = TreeRangeSet.create();</span><br><span class="line"></span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">numberRangeSet.add(Range.closed(<span class="number">15</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(numberRangeSet.rangeContaining(<span class="number">7</span>)); <span class="comment">// [3..10]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="RangeMap"><a href="#RangeMap" class="headerlink" title="RangeMap"></a>RangeMap</h3><p>RangeMap是一组不相连的、非空的区间与指定值的映射，基本实现为TreeRangeMap光这样说有点抽象，看些例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();</span><br><span class="line">rangeMap.put(Range.closed(<span class="number">1</span>, <span class="number">10</span>), <span class="string">"foo"</span>);</span><br><span class="line">System.out.println(rangeMap); <span class="comment">// [[1..10]=foo]</span></span><br><span class="line"></span><br><span class="line">rangeMap.put(Range.open(<span class="number">3</span>, <span class="number">6</span>), <span class="string">"bar"</span>);</span><br><span class="line">System.out.println(rangeMap); <span class="comment">// [[1..3]=foo, (3..6)=bar, [6..10]=foo]</span></span><br><span class="line"></span><br><span class="line">rangeMap.put(Range.open(<span class="number">10</span>, <span class="number">20</span>), <span class="string">"eoo"</span>);</span><br><span class="line">System.out.println(rangeMap); <span class="comment">// [[1..3]=foo, (3..6)=bar, [6..10]=foo, (10..20)=eoo]</span></span><br><span class="line"></span><br><span class="line">rangeMap.remove(Range.closed(<span class="number">5</span>, <span class="number">11</span>));</span><br><span class="line">System.out.println(rangeMap); <span class="comment">// [[1..3]=foo, (3..5)=bar, (11..20)=eoo]</span></span><br></pre></td></tr></table></figure><p></p><p>从RangeMap中获取一个Entry：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();</span><br><span class="line"></span><br><span class="line">rangeMap.put(Range.closed(<span class="number">0</span>, <span class="number">2</span>), <span class="string">"foo"</span>);</span><br><span class="line">rangeMap.put(Range.closed(<span class="number">3</span>, <span class="number">5</span>), <span class="string">"bar"</span>);</span><br><span class="line">rangeMap.put(Range.closed(<span class="number">6</span>, <span class="number">8</span>), <span class="string">"eoo"</span>);</span><br><span class="line">Map.Entry&lt;Range&lt;Integer&gt;, String&gt; entry = rangeMap.getEntry(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(entry.getKey()); <span class="comment">// [6..8]</span></span><br><span class="line">System.out.println(entry.getValue()); <span class="comment">// eoo</span></span><br></pre></td></tr></table></figure><p></p><p>剩下的操作和RangeSet差不多。</p><h3 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h3><p>BiMap是一种特殊的，双向映射的Map，可以确保不会出现重复的值并且我们总是可以安全地通过key获取到value。BiMap的基本实现为HashBiMap。</p><p>看看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">biMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">biMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">biMap.put(<span class="string">"k3"</span>, <span class="string">"v3"</span>);</span><br><span class="line">System.out.println(biMap); <span class="comment">// &#123;k1=v1, k2=v2, k3=v3&#125;</span></span><br><span class="line"></span><br><span class="line">BiMap&lt;String, String&gt; inverse = biMap.inverse();</span><br><span class="line">System.out.println(inverse); <span class="comment">// &#123;v1=k1, v2=k2, v3=k3&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>通过<code>inverse</code>可以得到值，键映射的BiMap。</p><p>往BiMap里添加重复的值将会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">biMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">biMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">biMap.put(<span class="string">"k3"</span>, <span class="string">"v1"</span>);</span><br></pre></td></tr></table></figure><p><img src="img/QQ截图20190422172835.png" alt="QQ截图20190422172835.png"></p><p>如果非要添加重复的值的话，可以用<code>forcePut</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = HashBiMap.create();</span><br><span class="line">biMap.put(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">biMap.put(<span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">biMap.forcePut(<span class="string">"k3"</span>, <span class="string">"v1"</span>);</span><br><span class="line">System.out.println(biMap); <span class="comment">// &#123;k2=v2, k3=v1&#125;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>Table是一个包含行，列和单元格的集合类型，行和列组成有序键对。</p><p>创建一个HashBasedTable（内部使用LinkedHashMap）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, Integer&gt; hashBasedTable = HashBasedTable.create();</span><br></pre></td></tr></table></figure><p></p><p>如果需要对table的行和列按照自然顺序或者提供的排序规则进行排序的话，可以创建一个TreeBasedTable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, Integer&gt; treeBasedTable = TreeBasedTable.create();</span><br></pre></td></tr></table></figure><p></p><p>如果事先知道行和列的值，并且table大小是固定的话，可以使用ArrayTable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; row = Lists.newArrayList(<span class="string">"r1"</span>, <span class="string">"r2"</span>);</span><br><span class="line">List&lt;String&gt; column = Lists.newArrayList(<span class="string">"c1"</span>, <span class="string">"c2"</span>, <span class="string">"c3"</span>);</span><br><span class="line">Table&lt;String, String, Integer&gt; arrayTable = ArrayTable.create(row, column);</span><br><span class="line">System.out.println(arrayTable); <span class="comment">// &#123;r1=&#123;c1=null, c2=null, c3=null&#125;, r2=&#123;c1=null, c2=null, c3=null&#125;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>上面例子创建了一个两行三列的table。</p><p>创建不可变table：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; immutableTable = ImmutableTable.&lt;String, String, String&gt; builder()</span><br><span class="line">        .put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p></p><p>通过行和列获取单元格的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashBasedTable); <span class="comment">// &#123;r1=&#123;c1=hello, c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">String v1 = hashBasedTable.get(<span class="string">"r1"</span>, <span class="string">"c1"</span>);</span><br><span class="line">String v2 = hashBasedTable.get(<span class="string">"r2"</span>, <span class="string">"c3"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(v1); <span class="comment">// hello</span></span><br><span class="line">System.out.println(v2); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p></p><p>我们可以检测table是否包含某个行键，某个列键，某个值和某个行和列组合的键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = hashBasedTable.contains(<span class="string">"r1"</span>, <span class="string">"c2"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = hashBasedTable.containsColumn(<span class="string">"c3"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = hashBasedTable.containsRow(<span class="string">"r2"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = hashBasedTable.containsValue(<span class="string">"world"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><p>通过行和列删除单元格，返回被删除的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">String removeValue = hashBasedTable.remove(<span class="string">"r1"</span>, <span class="string">"c1"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(removeValue); <span class="comment">// hello</span></span><br><span class="line">System.out.println(hashBasedTable); <span class="comment">// &#123;r1=&#123;c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>我们可以通过行或列得到一个Map，如果通过行得到Map，那么Map的键为列值，Map的值为对应单元格的值，光说有点抽象，看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; c2Map = hashBasedTable.column(<span class="string">"c2"</span>);</span><br><span class="line">Map&lt;String, String&gt; r1Map = hashBasedTable.row(<span class="string">"r1"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(c2Map); <span class="comment">// &#123;r1=world, r2=bye&#125;</span></span><br><span class="line">System.out.println(r1Map); <span class="comment">// &#123;c1=hello, c2=world&#125;</span></span><br><span class="line">System.out.println(c2Map.get(<span class="string">"r1"</span>)); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><p></p><p>我们还可以单独获取所有行或者所有列组成的Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, Map&lt;String, String&gt;&gt; columnMap = hashBasedTable.columnMap();</span><br><span class="line">Map&lt;String, Map&lt;String, String&gt;&gt; rowMap = hashBasedTable.rowMap();</span><br><span class="line"></span><br><span class="line">System.out.println(columnMap); <span class="comment">// &#123;c1=&#123;r1=hello, r2=good&#125;, c2=&#123;r1=world, r2=bye&#125;&#125;</span></span><br><span class="line">System.out.println(rowMap); <span class="comment">// &#123;r1=&#123;c1=hello, c2=world&#125;, r2=&#123;c1=good, c2=bye&#125;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>获取所有行键、列键或者值的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Table&lt;String, String, String&gt; hashBasedTable = HashBasedTable.create();</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c1"</span>, <span class="string">"hello"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r1"</span>, <span class="string">"c2"</span>, <span class="string">"world"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c1"</span>, <span class="string">"good"</span>);</span><br><span class="line">hashBasedTable.put(<span class="string">"r2"</span>, <span class="string">"c2"</span>, <span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; rowKeySet = hashBasedTable.rowKeySet();</span><br><span class="line">Set&lt;String&gt; columnKeySet = hashBasedTable.columnKeySet();</span><br><span class="line">Set&lt;Table.Cell&lt;String, String, String&gt;&gt; cells = hashBasedTable.cellSet();</span><br><span class="line"></span><br><span class="line">System.out.println(rowKeySet); <span class="comment">// [r1, r2]</span></span><br><span class="line">System.out.println(columnKeySet); <span class="comment">// [c1, c2]</span></span><br><span class="line">System.out.println(cells); <span class="comment">// [(r1,c1)=hello, (r1,c2)=world, (r2,c1)=good, (r2,c2)=bye]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h3><p>Multiset和java.util.set类似，不过Mutiset可以添加重复的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create();</span><br><span class="line">hashMultiset.add(<span class="string">"are you ok?"</span>);</span><br><span class="line">hashMultiset.add(<span class="string">"are you ok?"</span>);</span><br><span class="line">hashMultiset.add(<span class="string">"are you ok?"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashMultiset); <span class="comment">// [are you ok? x 3]</span></span><br><span class="line"></span><br><span class="line">hashMultiset.remove(<span class="string">"are you ok?"</span>);</span><br><span class="line">System.out.println(hashMultiset); <span class="comment">// [are you ok? x 2]</span></span><br><span class="line"></span><br><span class="line">hashMultiset.setCount(<span class="string">"are you ok?"</span>, <span class="number">10</span>); <span class="comment">// 直接设置元素个数</span></span><br><span class="line">System.out.println(hashMultiset); <span class="comment">// [are you ok? x 10]</span></span><br></pre></td></tr></table></figure><p></p><p>在并发环境下，我们可以使用ConcurrentHashMultiset，它的add和remove方法是线程安全的。唯一值得注意的是，在并发环境下使用setCount方法时候，需使用下面这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMultiset&lt;String&gt; hashMultiset = HashMultiset.create();</span><br><span class="line">hashMultiset.setCount(<span class="string">"are you ok?"</span>, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">hashMultiset.setCount(<span class="string">"are you ok?"</span>, <span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(hashMultiset); <span class="comment">// [are you ok? x 5]</span></span><br></pre></td></tr></table></figure><p></p><p>第一个参数为需要添加的值，第二个参数为当前Multiset里元素个数，第三个参数为需要添加的元素个数。只有第二个参数的值正确的时候，setCount才有效，所以<code>hashMultiset.setCount(&quot;are you ok?&quot;, 10, 5)</code>实际上是不生效的。</p><h3 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h3><p>Multimap可以通过一个键映射多个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"hello"</span>;</span><br><span class="line">ArrayListMultimap&lt;String, String&gt; multimap = ArrayListMultimap.create();</span><br><span class="line">multimap.put(key, <span class="string">"world"</span>);</span><br><span class="line">multimap.put(key, <span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(multimap); <span class="comment">// &#123;hello=[world, java]&#125;</span></span><br><span class="line">System.out.println(multimap.get(key)); <span class="comment">// [world, java]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="ClassToInstanceMap"><a href="#ClassToInstanceMap" class="headerlink" title="ClassToInstanceMap"></a>ClassToInstanceMap</h3><p>使用类型作为键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MutableClassToInstanceMap&lt;Object&gt; classToInstanceMap = MutableClassToInstanceMap.create();</span><br><span class="line">classToInstanceMap.put(String.class, <span class="string">"hello"</span>);</span><br><span class="line">classToInstanceMap.put(Integer.class, <span class="number">777</span>);</span><br><span class="line">classToInstanceMap.put(Double.class, <span class="number">43.96</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(classToInstanceMap); <span class="comment">// &#123;class java.lang.Double=43.96, class java.lang.String=hello, class java.lang.Integer=777&#125;</span></span><br><span class="line">System.out.println(classToInstanceMap.get(Double.class)); <span class="comment">// 43.96</span></span><br></pre></td></tr></table></figure><p></p><h2 id="Lists、Maps-amp-Sets"><a href="#Lists、Maps-amp-Sets" class="headerlink" title="Lists、Maps&amp;Sets"></a>Lists、Maps&amp;Sets</h2><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>创建一个List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><p></p><p>反转List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; reverse = Lists.reverse(list);</span><br><span class="line">System.out.println(reverse); <span class="comment">// [c, b, a]</span></span><br></pre></td></tr></table></figure><p></p><p>通过字符串生成字符集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Character&gt; characters = Lists.charactersOf(<span class="string">"mrbird"</span>);</span><br><span class="line">System.out.println(characters); <span class="comment">// [m, r, b, i, r, d]</span></span><br></pre></td></tr></table></figure><p></p><p>将集合按照指定区块大小分区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"php"</span>, <span class="string">"go"</span>, <span class="string">"python"</span>, <span class="string">"c#"</span>, <span class="string">"javascript"</span>);</span><br><span class="line">List&lt;List&lt;String&gt;&gt; partition = Lists.partition(list, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(partition); <span class="comment">// [[java, php], [go, python], [c#, javascript]]</span></span><br></pre></td></tr></table></figure><p></p><p>一个删除List中重复项的技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"p"</span>, <span class="string">"p"</span>, <span class="string">"l"</span>, <span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line">ImmutableList&lt;String&gt; newList = ImmutableSet.copyOf(list).asList();</span><br><span class="line">System.out.println(newList); <span class="comment">// [a, p, l, e]</span></span><br></pre></td></tr></table></figure><p></p><p>从集合中删除null值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="keyword">null</span>,<span class="string">" python"</span>);</span><br><span class="line"></span><br><span class="line">Iterables.removeIf(list, Objects::isNull);</span><br><span class="line">System.out.println(list); <span class="comment">// [java, python]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p>通过Sets创建set：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Object&gt; hashSet = Sets.newHashSet();</span><br></pre></td></tr></table></figure><p></p><p>合并两个Set：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = ImmutableSet.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">Set&lt;String&gt; set2 = ImmutableSet.of(<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; union = Sets.union(set1, set2);</span><br><span class="line">System.out.println(union); <span class="comment">// [a, b, c, d]</span></span><br></pre></td></tr></table></figure><p></p><p>可以通过<code>Sets.cartesianProduct()</code>获取两个Set的笛卡尔积：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; first = ImmutableSet.of(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">Set&lt;Character&gt; second = ImmutableSet.of(<span class="string">'c'</span>, <span class="string">'d'</span>);</span><br><span class="line">Set&lt;List&lt;Character&gt;&gt; result = Sets.cartesianProduct(first, second);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [[a, c], [a, d], [b, c], [b, d]]</span></span><br></pre></td></tr></table></figure><p></p><p>获取两个Set的交集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; first = ImmutableSet.of(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">Set&lt;Character&gt; second = ImmutableSet.of(<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line">Set&lt;Character&gt; intersection = Sets.intersection(first, second);</span><br><span class="line"></span><br><span class="line">System.out.println(intersection); <span class="comment">// [c]</span></span><br></pre></td></tr></table></figure><p></p><p>获取两个Set的差集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; first = ImmutableSet.of(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">Set&lt;Character&gt; second = ImmutableSet.of(<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line">Set&lt;Character&gt; difference = Sets.symmetricDifference(first, second);</span><br><span class="line"></span><br><span class="line">System.out.println(difference); <span class="comment">// [a, b, d, e]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>通过Maps创建Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; map = Maps.newHashMap();</span><br></pre></td></tr></table></figure><p></p><p>创建期望大小的Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; map = Maps.newHashMapWithExpectedSize(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p></p><h2 id="Joiner与Splitter"><a href="#Joiner与Splitter" class="headerlink" title="Joiner与Splitter"></a>Joiner与Splitter</h2><h3 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h3><p>Joiner用于连接操作。比如将List里的元素通过“,”连接成一个字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">String join = Joiner.on(<span class="string">","</span>).join(list);</span><br><span class="line"></span><br><span class="line">System.out.println(join); <span class="comment">// a,b,c</span></span><br></pre></td></tr></table></figure><p></p><p>使用Joiner将Map转换为String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"scott"</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">String join = Joiner.on(<span class="string">","</span>).withKeyValueSeparator(<span class="string">"~"</span>).join(map);</span><br><span class="line">System.out.println(join); <span class="comment">// mrbird~18,scott~28</span></span><br></pre></td></tr></table></figure><p></p><p>在使用Joiner的时候，如果集合中含有null值，我们可以选择跳过它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="keyword">null</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">String result = Joiner.on(<span class="string">","</span>).skipNulls().join(list);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// a,b,c,d</span></span><br></pre></td></tr></table></figure><p></p><p>或者使用指定值替代null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>, <span class="keyword">null</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>);</span><br><span class="line">String result = Joiner.on(<span class="string">","</span>).useForNull(<span class="string">"空"</span>).join(list);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// a,空,b,c,d</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h3><p>Splitter用于将String拆分为集合类型，看个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="string">"a,b,c,d      "</span>;</span><br><span class="line">List&lt;String&gt; list = Splitter.on(<span class="string">","</span>).trimResults().splitToList(value);</span><br><span class="line"></span><br><span class="line">System.out.println(list); <span class="comment">// [a, b, c, d]</span></span><br></pre></td></tr></table></figure><p></p><p>使用Splitter将String拆分为Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> String value = <span class="string">"mrbird=18,scott=28"</span>;</span><br><span class="line">Map&lt;String, String&gt; map = Splitter.on(<span class="string">","</span>).withKeyValueSeparator(<span class="string">"="</span>).split(value);</span><br><span class="line"></span><br><span class="line">System.out.println(map); <span class="comment">// &#123;mrbird=18, scott=28&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>分割具有多种分隔符的String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="string">"a.b,,c,,.."</span>;</span><br><span class="line">List&lt;String&gt; result = Splitter.onPattern(<span class="string">"[.,]"</span>).omitEmptyStrings().splitToList(value);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [a, b, c]</span></span><br></pre></td></tr></table></figure><p></p><p><code>omitEmptyStrings</code>用于忽略空字符串。</p><p>我们还可以通过指定长度来拆分字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="string">"人们都说：“桂林山水甲天下”，我们乘着木船荡漾在漓江上，来观赏桂林的山水。"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Splitter.fixedLength(<span class="number">3</span>).splitToList(value);</span><br><span class="line">System.out.println(list); <span class="comment">// [人们都, 说：“, 桂林山, 水甲天, 下”，, 我们乘, 着木船, 荡漾在, 漓江上, ，来观, 赏桂林, 的山水, 。]</span></span><br></pre></td></tr></table></figure><p></p><p>也可以指定拆分项的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String value = <span class="string">"a-b-c-d-e"</span>;</span><br><span class="line">List&lt;String&gt; result = Splitter.on(<span class="string">"-"</span>).limit(<span class="number">4</span>).splitToList(value);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [a, b, c, d-e]</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到d-e没有被拆分。</p><h2 id="Filter-amp-Transform"><a href="#Filter-amp-Transform" class="headerlink" title="Filter&amp;Transform"></a>Filter&amp;Transform</h2><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>可以通过Guava提供的Predicates来实现各种集合过滤操作。</p><p>比如找出集合中包含a的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"javascript"</span>, <span class="string">"c#"</span>, <span class="string">"golang"</span>);</span><br><span class="line">Iterable&lt;String&gt; result = Iterables.filter(list, Predicates.containsPattern(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [java, javascript, golang]</span></span><br></pre></td></tr></table></figure><p></p><p>上面的例子也可以通过<code>Collections2.filter</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"javascript"</span>, <span class="string">"c#"</span>, <span class="string">"golang"</span>);</span><br><span class="line">Collection&lt;String&gt; result = Collections2.filter(list, Predicates.containsPattern(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p></p><p>我们也可以编写自定义的过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Predicate&lt;String&gt; predicate = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.endsWith(<span class="string">"a"</span>) || input.contains(<span class="string">"#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.apply(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"javascript"</span>, <span class="string">"c#"</span>, <span class="string">"golang"</span>);</span><br><span class="line">Collection&lt;String&gt; result = Collections2.filter(list, predicate);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [java, c#]</span></span><br></pre></td></tr></table></figure><p></p><p>组合多个过滤条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"javascript"</span>, <span class="string">"c#"</span>, <span class="string">"golang"</span>);</span><br><span class="line">Collection&lt;String&gt; result = Collections2.filter(list,</span><br><span class="line">        Predicates.or(</span><br><span class="line">                Predicates.containsPattern(<span class="string">"a"</span>),</span><br><span class="line">                Predicates.containsPattern(<span class="string">"#"</span>)</span><br><span class="line">        ));</span><br><span class="line">System.out.println(result); <span class="comment">// [java, javascript, c#, golang]</span></span><br></pre></td></tr></table></figure><p></p><p>过滤掉集合中的null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="keyword">null</span>,<span class="string">" python"</span>);</span><br><span class="line">Collection&lt;String&gt; result = Collections2.filter(list, Predicates.&lt;String&gt;notNull());</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [java,  python]</span></span><br></pre></td></tr></table></figure><p></p><p>检测集合中是否有包含a字符的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"c#"</span>,<span class="string">" python"</span>);</span><br><span class="line"><span class="keyword">boolean</span> result = Iterables.any(list, Predicates.containsPattern(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>将集合转换为元素长度的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; function = <span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(@Nullable String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"c#"</span>, <span class="string">" python"</span>);</span><br><span class="line">Iterable&lt;Integer&gt; result = Iterables.transform(list, function);</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [4, 2, 7]</span></span><br></pre></td></tr></table></figure><p></p><p>上面的例子同样可以使用<code>Collections2.transform</code>来代替<code>Iterables.transform</code>。</p><p>我们也可以通过<code>Functions.fromPredicate</code>来创建简单的转换函数Function：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"c#"</span>, <span class="string">" python"</span>);</span><br><span class="line">Iterable&lt;Boolean&gt; result = Iterables.transform(list, Functions.forPredicate(Predicates.containsPattern(<span class="string">"#"</span>)));</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [false, true, false]</span></span><br></pre></td></tr></table></figure><p></p><p>组合多个转换函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, String&gt; f1 = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i like "</span> + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; f2 = <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"c#"</span>, <span class="string">" python"</span>);</span><br><span class="line">Iterable&lt;String&gt; result = Iterables.transform(list, Functions.compose(f2, f1));</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [I LIKE JAVA, I LIKE C#, I LIKE  PYTHON]</span></span><br></pre></td></tr></table></figure><p></p><p>我们也可以将过滤和转换组合在一起使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.startsWith(<span class="string">"j"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.apply(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; function = <span class="keyword">new</span> Function&lt;String,String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"java"</span>, <span class="string">"c#"</span>, <span class="string">"javascript"</span>, <span class="string">"python"</span>);</span><br><span class="line">ImmutableList&lt;String&gt; result = FluentIterable.from(list)</span><br><span class="line">        .filter(predicate)</span><br><span class="line">        .transform(function)</span><br><span class="line">        .toList();</span><br><span class="line"></span><br><span class="line">System.out.println(result); <span class="comment">// [JAVA, JAVASCRIPT]</span></span><br></pre></td></tr></table></figure><p></p><h2 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h2><p>除了上面涉及的Iterables的用法外，其还提供了许多别的好用的方法。</p><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><p>该方法用于从特定集合中删除给定集合中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; removeFrom = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; elementsToRemove = Lists.newArrayList(<span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = Iterables.removeAll(removeFrom, elementsToRemove);</span><br><span class="line">System.out.println(result); <span class="comment">// true</span></span><br><span class="line">System.out.println(removeFrom); <span class="comment">// [a]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="retainAll"><a href="#retainAll" class="headerlink" title="retainAll"></a>retainAll</h3><p>retainAll的功能和removeAll相反：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; removeFrom = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; elementsToRetain = Lists.newArrayList(<span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = Iterables.retainAll(removeFrom, elementsToRetain);</span><br><span class="line">System.out.println(result); <span class="comment">// true</span></span><br><span class="line">System.out.println(removeFrom); <span class="comment">// [b, c]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><p>addAll用于将给定集合添加到现有集合中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = Iterables.addAll(list1, list2); <span class="comment">// true</span></span><br><span class="line">System.out.println(list1); <span class="comment">// [a, b, c, b, c]</span></span><br></pre></td></tr></table></figure><p></p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p>concat用于合并集合，组成一个新的集合对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Lists.newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">Iterable&lt;String&gt; result = Iterables.concat(list1,list2);</span><br><span class="line">System.out.println(result); <span class="comment">// [a, b, c, b, c]</span></span><br></pre></td></tr></table></figure><p></p><p>Iterables还包含许多别的实用方法：</p><p><img src="img/QQ截图20190423231111.png" alt="QQ截图20190423231111.png"></p><p>这里就不一一演示了，溜了。</p><p><img src="img/QQ图片20190423231252.png" alt="QQ图片20190423231252.png"></p><p>更详细的内容可以参考guava官方wiki：<a href="https://github.com/google/guava/wiki" target="_blank" rel="noopener">https://github.com/google/guava/wiki</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;不可变集合&quot;&gt;&lt;a href=&quot;#不可变集合&quot; class=&quot;headerlink&quot; title=&quot;不可变集合&quot;&gt;&lt;/a&gt;不可变集合&lt;/h2&gt;&lt;p&gt;不可变集合例子：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImmutableSet&amp;lt;String&amp;gt; FRUITS = ImmutableSet.of(&lt;span class=&quot;string&quot;&gt;&quot;apple&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;watermelon&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;cherry&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;mango&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FRUITS.remove(&lt;span class=&quot;string&quot;&gt;&quot;apple&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将抛出&lt;code&gt;java.lang.UnsupportedOperationException&lt;/code&gt;异常：
    
    </summary>
    
    
      <category term="guava" scheme="http://mrbird.cc/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>FEBS-Vue文档</title>
    <link href="http://mrbird.cc/FEBS-Vue-Document.html"/>
    <id>http://mrbird.cc/FEBS-Vue-Document.html</id>
    <published>2019-01-01T01:24:51.000Z</published>
    <updated>2019-07-12T13:02:30.446Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:16 GMT+0800 (GMT+08:00) --><p>FEBS-Vue为<a href="https://github.com/wuyouzhuguli/FEBS-Shiro" target="_blank" rel="noopener">FEBS-Shiro</a>的前后端分离版本，前端使用Vue全家桶，组件库采用<a href="https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant-Design-Vue</a>。</p><p>文档里介绍的示例是在Windows10操作系统下完成的，后端编辑器使用IDEA，前端编辑器使用WebStorm。<a id="more"></a></p><h2 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h2><p>为了方便，我直接在桌面上通过git bash克隆项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/wuyouzhuguli/FEBS-Vue.git</span><br></pre></td></tr></table></figure><p></p><p>克隆后，桌面上多出一个FEBS-Vue文件夹：</p><p><img src="img/febsvue/20190409165245.png" alt="QQ截图20190409165245.png"></p><p>backend为后端项目源码，frontend为前端项目源码，sql为数据库初始化脚本。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>因为项目用到了JDK 8的一些特性，所以JDK最低版本不能低于8。</p><p>JDK 8官方下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads。" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads。</a></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Node.js下载地址：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a>，直接安装即可，安装后查看其版本：</p><p><img src="img/febsvue/QQ截图20190409170853.png" alt="QQ截图20190409170853.png"></p><p>Node.js集成了npm，所以安装好Node.js后npm就可以使用了：</p><p><img src="img/febsvue/QQ截图20190409171301.png" alt="QQ截图20190409171301.png"></p><h3 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h3><p>在CMD中执行<code>npm install -g yarn</code>：</p><p><img src="img/febsvue/QQ截图20190409171954.png" alt="QQ截图20190409171954.png"></p><p>因为我之前已经安装过了，所以这里就相当于更新操作了。</p><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>项目缓存数据库使用的是Redis，所以在导入项目前需先安装Redis。</p><p>Redis Windows版本下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a>。直接下载zip版本解压到任意目录即可。</p><p>下载后，使用cmd命令切换到Redis根目录，然后运行<code>redis-server.exe redis.windows.conf</code>启动即可：</p><p><img src="img/febsvue/QQ截图20190409172902.png" alt="QQ截图20190409172902.png"></p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>项目数据库采用MySQL社区版，版本为5.7.x。</p><p>下载地址：<a href="https://dev.mysql.com/downloads/windows/installer/5.7.html" target="_blank" rel="noopener">https://dev.mysql.com/downloads/windows/installer/5.7.html</a></p><h3 id="导入SQL"><a href="#导入SQL" class="headerlink" title="导入SQL"></a>导入SQL</h3><p>使用Navicat新建一个数据库：</p><p><img src="img/febsvue/QQ截图20190409173934.png" alt="QQ截图20190409173934.png"></p><p>然后导入SQL脚本即可。</p><h3 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h3><p>IDEA选择backend： <img src="img/febsvue/QQ截图20190409184301.png" alt="QQ截图20190409184301.png"></p><p>导入项目后安装lombok插件（不懂lombok可以自行百度）：</p><p><img src="img/febsvue/QQ截图20190409185417.png" alt="QQ截图20190409185417.png"></p><p>安装完重启IDEA才能生效。</p><p>接着修改application.yml中的数据库和Redis配置，修改完后通过Spring Boot入口类FebsApplication启动即可：</p><p><img src="img/febsvue/QQ截图20190409184818.png" alt="QQ截图20190409184818.png"></p><p><img src="img/febsvue/QQ截图20190409185112.png" alt="QQ截图20190409185112.png"></p><p>接着开始导入前端项目。</p><h3 id="导入前端项目"><a href="#导入前端项目" class="headerlink" title="导入前端项目"></a>导入前端项目</h3><p>使用WebStorm打开frontend：</p><p><img src="img/febsvue/QQ截图20190409185643.png" alt="QQ截图20190409185643.png"></p><p>在终端输入<code>yarn install</code>命令安装依赖：</p><p><img src="img/febsvue/QQ截图20190409190322.png" alt="QQ截图20190409190322.png"></p><p>稍等片刻，坐与放宽。</p><p>依赖下载完毕后，输入yarn start启动前端项目：</p><p><img src="img/febsvue/QQ截图20190409191649.png" alt="QQ截图20190409191649.png"></p><p>浏览器访问<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a>：</p><p><img src="img/febsvue/QQ截图20190409191833.png" alt="QQ截图20190409191833.png"></p><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>下面演示如何在Linux上部署项目（例子采用CentOS7）。</p><h3 id="Vagrant创建CentOS"><a href="#Vagrant创建CentOS" class="headerlink" title="Vagrant创建CentOS"></a>Vagrant创建CentOS</h3><p>如果没有CentOS7环境可以使用Vagrant快速构建一个CentOS虚拟机，具体可以参考：<a href="https://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html">https://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html</a>。我的CentOS虚拟机IP为：192.168.33.11。</p><div class="note danger"><p>使用命令<code>timedatectl set-timezone Asia/Shanghai</code>设置CentOS的时区，以避免因时区带来的BUG。</p></div><h3 id="Java环境配置"><a href="#Java环境配置" class="headerlink" title="Java环境配置"></a>Java环境配置</h3><ol><li>下载JDK8：</li></ol><p><img src="img/febsvue/QQ截图20190409204143.png" alt="QQ截图20190409204143.png"></p><p>下载后通过Vagrant共享到CentOS上（我的Vagrantfile共享配置为<code>config.vm.synced_folder &quot;./sync&quot;, &quot;/vagrant&quot;, create:true, owner: &quot;root&quot;, group: &quot;root&quot;</code>）：</p><p><img src="img/febsvue/QQ截图20190409204745.png" alt="QQ截图20190409204745.png"></p><ol start="2"><li>安装JDK8：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u201-linux-x64.rpm</span><br></pre></td></tr></table></figure><p><img src="img/febsvue/QQ截图20190409204849.png" alt="QQ截图20190409204849.png"></p><ol start="3"><li>配置环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_201</span><br><span class="line">JRE_HOME=/usr/java/jdk1.8.0_201/jre</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><p>然后执行以下命令生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p></p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>官方安装教程：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p>安装好后：</p><p><img src="img/febsvue/QQ截图20190409205834.png" alt="QQ截图20190409205834.png"></p><h3 id="Docker安装MySQL"><a href="#Docker安装MySQL" class="headerlink" title="Docker安装MySQL"></a>Docker安装MySQL</h3><ol><li>拉取MySQL镜像：</li></ol><p><img src="img/febsvue/QQ截图20190409210335.png" alt="QQ截图20190409210335.png"></p><ol start="2"><li>创建目录/home/febs/mysql，用于挂载MySQL volume:</li></ol><p><img src="img/febsvue/QQ截图20190409210901.png" alt="QQ截图20190409210901.png"></p><ol start="3"><li>创建MySQL容器：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql -p 3306:3306 \</span><br><span class="line"> -v $(<span class="built_in">pwd</span>):/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.25</span><br></pre></td></tr></table></figure><p><img src="img/febsvue/QQ截图20190409211225.png" alt="QQ截图20190409211225.png"></p><ol start="4"><li>使用Navicat连接MySQL，创建数据库并导入数据：</li></ol><p>连接：</p><p><img src="img/febsvue/QQ截图20190409211912.png" alt="QQ截图20190409211912.png"></p><p>新增数据库：</p><p><img src="img/febsvue/QQ截图20190409212130.png" alt="QQ截图20190409212130.png"></p><p>导入SQL：</p><p><img src="img/febsvue/QQ截图20190409212334.png" alt="QQ截图20190409212334.png"></p><h3 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h3><ol><li>拉取Redis镜像:</li></ol><p><img src="img/febsvue/QQ截图20190409213345.png" alt="QQ截图20190409213345.png"></p><ol start="2"><li>创建文件/home/febs/redis/conf/redis.conf，用于挂载Redis配置文件：</li></ol><p><img src="img/febsvue/QQ截图20190409223016.png" alt="QQ截图20190409213604.png"></p><ol start="3"><li>创建Redis容器：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 \</span><br><span class="line"> -v /home/febs/redis/conf/redis.conf:/usr/<span class="built_in">local</span>/etc/redis/redis.conf \</span><br><span class="line"> --name redis redis:4.0.14</span><br></pre></td></tr></table></figure><p>测试连接：</p><p><img src="img/febsvue/2019-04-10_094404.png" alt="QQ截图20190410094147.png"></p><h3 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h3><ol><li>拉取Nginx镜像:</li></ol><p><img src="img/febsvue/QQ截图20190409220000.png" alt="QQ截图20190409220000.png"></p><ol start="2"><li>创建目录/home/febs/nginx/html、/home/febs/nginx/logs和文件/home/febs/nginx/conf/nginx.conf，分别用于挂载Nginx html,logs和配置文件：</li></ol><p><img src="img/febsvue/20190409225225.png" alt="QQ截图20190409225225.png"> <img src="img/febsvue/20190409223442.png" alt="QQ截图20190409220212.png"></p><ol start="3"><li>修改Nginx配置：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /home/febs/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>   /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span>   /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">        <span class="attribute">include</span> mime.types;</span><br><span class="line">        <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_names_hash_bucket_size</span> <span class="number">512</span>;</span><br><span class="line">        <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">        <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">        <span class="attribute">client_max_body_size</span> <span class="number">50m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">sendfile</span>   <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line">        <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">256k</span>;</span><br><span class="line">        <span class="attribute">fastcgi_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">gzip_min_length</span>  <span class="number">1k</span>;</span><br><span class="line">        <span class="attribute">gzip_buffers</span>     <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">        <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">gzip_comp_level</span> <span class="number">6</span>;</span><br><span class="line">        <span class="attribute">gzip_types</span>     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;</span><br><span class="line">        <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">gzip_proxied</span>   expired <span class="literal">no</span>-cache <span class="literal">no</span>-store private auth;</span><br><span class="line">        <span class="attribute">gzip_disable</span>   <span class="string">"MSIE [1-6]\."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=perip:<span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">limit_conn_zone</span> <span class="variable">$server_name</span> zone=perserver:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建Nginx容器：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -d -p 80:80  \</span><br><span class="line">-v /home/febs/nginx/conf/nginx.conf:/etc/ng inx/nginx.conf  \</span><br><span class="line">-v /home/febs/nginx/html:/etc/nginx/html \</span><br><span class="line">-v /home/febs/nginx/logs:/var/<span class="built_in">log</span>/nginx nginx:1.14.2</span><br></pre></td></tr></table></figure><h3 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h3><p>修改application.yml中数据库和redis的连接配置，然后将项目打包成jar文件：</p><p><img src="img/febsvue/2019-04-10_094842.png" alt="2019-04-10_094842.png"></p><p>将其上传到CentOS虚拟机的/home/febs/backend目录下：</p><p><img src="img/febsvue/asdfasdfasd.png" alt="2019-04-10_100008.png"></p><p>编写一个启动项目的shell脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim start.sh</span><br></pre></td></tr></table></figure><p></p><p>内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar febs_shiro_jwt-1.0.0-release.jar &amp;</span><br></pre></td></tr></table></figure><p></p><p>编写一个关停项目的shell脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim stop.sh</span><br></pre></td></tr></table></figure><p></p><p>内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID=`ps -ef | grep febs_shiro_jwt-1.0.0-release.jar | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">if [ -z &quot;$PID&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo Application is already stopped</span><br><span class="line">else</span><br><span class="line">    echo kill $PID</span><br><span class="line">    kill -9 $PID</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p></p><p>授权，让其可执行：</p><p><img src="img/febsvue/2019-04-10_100815.png" alt="2019-04-10_100815.png"></p><p>启动项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./start.sh</span><br><span class="line"></span><br><span class="line">tail -f nohup.out</span><br></pre></td></tr></table></figure><p></p><p>看到如下输出的时候说明后端项目启动成功：</p><p><img src="img/febsvue/2019-04-10_101222.png" alt="2019-04-10_101222.png"></p><h3 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h3><p>点击build：</p><p><img src="img/febsvue/2019-04-10_095141.png" alt="2019-04-10_095141.png"></p><p>build成功后，项目目录下会多出个dist文件夹：</p><p><img src="img/febsvue/2019-04-10_095533.png" alt="2019-04-10_095533.png"></p><p>将这个目录下的文件上传到CentOS虚拟机的/home/febs/nginx/html目录下：</p><p><img src="img/febsvue/2019-04-10_101510.png" alt="2019-04-10_101510.png"></p><p>浏览器访问<a href="http://192.168.33.11/#/login" target="_blank" rel="noopener">http://192.168.33.11/#/login</a>：</p><p><img src="img/febsvue/2019-04-10_101826.png" alt="2019-04-10_101826.png"></p><p><img src="img/febsvue/2019-04-10_104514.png" alt="2019-04-10_104514.png"></p><p>部署成功。</p><h2 id="后端项目介绍"><a href="#后端项目介绍" class="headerlink" title="后端项目介绍"></a>后端项目介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>后端项目目录含义如下图所示：</p><p><img src="img/febsvue/backend-xmind.png" alt="backend-xmind.png"></p><p>Common模块文件含义如下图所示：</p><p><img src="img/febsvue/2019-04-08_113758.png" alt="2019-04-08_113758.png"></p><p>其他模块文件较为简单，略。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>application.yml中除了各个插件的配置外，下面这段配置为系统配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">febs:</span></span><br><span class="line"><span class="attr">  openAopLog:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  max:</span></span><br><span class="line"><span class="attr">    batch:</span></span><br><span class="line"><span class="attr">      insert:</span></span><br><span class="line"><span class="attr">        num:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  shiro:</span></span><br><span class="line"><span class="attr">    anonUrl:</span> <span class="string">/login,/logout/**,/regist,/user/check/**</span></span><br><span class="line"><span class="attr">    jwtTimeOut:</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure><p></p><ul><li><p><code>febs.opAopLog</code>：Boolean类型，取值true或者false，为true时表示开启Aop记录用户的操作日志，需和<code>@Log</code>注解搭配使用。</p></li><li><p><code>febs.max.batch.insert.num</code>：大于0的Integer类型，表示Excel导入数据当次最大入库数据量。比如配置为1000时表示入库数据为0 - 1000 时只会执行一次数据库commit操作。</p></li><li><p><code>febs.shiro.anonUrl</code>：逗号分隔的字符串，表示无需认证的资源路径。</p></li><li><p><code>febs.shiro.jwtTimeOut</code>：定义token的有效时间，单位为秒，比如配置为3600表示token一个小时内有效，超过一个小时后需要重新认证。</p></li></ul><h3 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h3><p>系统Controller暴露的接口风格为RESTful，通过HTTP请求method对应增删改查类型，响应以HTTP Code为判断依据。</p><p>以UserController为例子：</p><table><tr><th>描述</th><th>请求URI</th><th>HTTP Method</th><th>对应注解</th></tr><tr><td>查询所有用户</td><td>/user</td><td>GET</td><td>@GetMapping</td></tr><tr><td>通过用户名查找用户</td><td>/user/{username}</td><td>GET</td><td>@GetMapping</td></tr><tr><td>新增用户</td><td>/user</td><td>POST</td><td>@PostMapping</td></tr><tr><td>修改用户</td><td>/user</td><td>PUT</td><td>@PutMapping</td></tr><tr><td>删除用户</td><td>/user/{userIds}</td><td>DELETE</td><td>@DeleteMapping</td></tr></table><p>Controller方法默认返回200状态码，当Controller抛出异常时，将被<code>GlobalExceptionHandler</code>捕获，根据异常类型，返回不同的HTTP状态码：</p><table><tr><th>异常类型</th><th>异常描述</th><th>状态码</th><th>对应常量</th></tr><tr><td>UnauthorizedException</td><td>未授权异常，权限不足异常</td><td>403</td><td>HttpStatus.FORBIDDEN</td></tr><tr><td>LimitAccessException</td><td>限制访问异常，访问接口频率超限</td><td>429</td><td>HttpStatus.TOO_MANY_REQUESTS</td></tr><tr><td>ConstraintViolationException</td><td>参数校验异常（普通传参）</td><td>400</td><td>HttpStatus.BAD_REQUEST</td></tr><tr><td>BindException</td><td>参数校验异常（实体对象传参）</td><td>400</td><td>HttpStatus.BAD_REQUEST</td></tr><tr><td>FebsException</td><td>Febs系统异常</td><td>500</td><td>HttpStatus.INTERNAL_SERVER_ERROR</td></tr><tr><td>Exception</td><td>剩下的别的异常</td><td>500</td><td>HttpStatus.INTERNAL_SERVER_ERROR</td></tr></table><h3 id="数据层介绍"><a href="#数据层介绍" class="headerlink" title="数据层介绍"></a>数据层介绍</h3><p>首先看看表结构，数据表分为两大类：定时任务表和系统表。</p><p><img src="img/febsvue/20190408141755.png" alt="QQ截图20190408141755.png"></p><p>以qrtz_开头的为定时任务表，定时任务有基于内存和基于数据库的，本项目使用的是基于数据库持久化的方案。要详细了解这些表可以参考文章：<a href="http://www.ibloger.net/article/2650.html" target="_blank" rel="noopener">http://www.ibloger.net/article/2650.html</a>。</p><p>以t_开头的为系统表，他们的关系如下所示:</p><p><img src="img/febsvue/2019-04-08_145115.png" alt="2019-04-08_145115.png"></p><p>其中用户，角色和权限之间的关系使用的是经典的RBAC（Role-Based Access Control，基于角色的访问控制）模型。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。如下图所示：</p><p><img src="img/febsvue/QQ截图20190408145646.png" alt="QQ截图20190408145646.png"></p><p>比如获取用户名为mrbrid的用户权限过程为：</p><ol><li><p>通过mrbrid的user_id从t_user_role表获取对应的role_id；</p></li><li><p>通过第1步获取的role_id从t_role_menu表获取对应的menu_id；</p></li><li><p>通过第2步获取的menu_id从t_menu获取menu相关信息（t_menu表的permission为权限信息）。</p></li></ol><p>数据层框架采用的是<a href="https://mp.baomidou.com/guide/" target="_blank" rel="noopener">MybatisPlus</a>，具体可以参考其官方文档。</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><p>登录逻辑如下图所示：</p><p><img src="img/febsvue/QQ截图20190408153154.png" alt="QQ截图20190408153154.png"></p><p>这里详细说明下登录成功后的第2步、第3步和第4步过程：</p><ul><li><p>登录成功后，构建一个ActiveUser对象，对应<code>LoginController</code>的<code>saveTokenToRedis</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建在线用户</span></span><br><span class="line">ActiveUser activeUser = <span class="keyword">new</span> ActiveUser();</span><br><span class="line">activeUser.setUsername(user.getUsername());</span><br><span class="line">activeUser.setIp(ip);</span><br><span class="line">activeUser.setToken(token.getToken());</span><br><span class="line">activeUser.setLoginAddress(AddressUtil.getCityInfo(DbSearcher.BTREE_ALGORITHM, ip));</span><br><span class="line"></span><br><span class="line"><span class="comment">// zset 存储登录用户，score 为过期时间戳</span></span><br><span class="line"><span class="keyword">this</span>.redisService.zadd(FebsConstant.ACTIVE_USERS_ZSET_PREFIX, Double.valueOf(token.getExipreAt()), mapper.writeValueAsString(activeUser));</span><br></pre></td></tr></table></figure><p>然后将<code>activeUser</code>通过<code>ObjectMapper</code>序列化，存储到Redis的Zset结构中，key为<code>FebsConstant.ACTIVE_USERS_ZSET_PREFIX</code>（即febs.user.active），score为该用户的登录过期时间点（即Tokean失效时间），value为<code>activeUser</code>序列化值。</p><div class="note info"><p>Zset它在set的基础上增加了一个顺序属性(score)，这一属性在添加修改元素时候可以指定，每次指定后，zset会自动重新按新的值调整顺序。可以理解为有两列字段的数据表，一列存value,一列存顺序编号。</p></div><p>Zset相关Redis命令：</p><p><img src="img/febsvue/redis-zset.png" alt="redis-zset.png"></p><p>比如当用户mrbird和scott登录成功后，查看Redis中key为febs.user.active的值:</p><p><img src="img/febsvue/QQ截图20190408154805.png" alt="QQ截图20190408154805.png"></p></li><li><p>将Token存储到Redis中：key为febs.cache.token.token值.IP地址，value为token值，有效期为token的有效时长，对应的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.redisService.set(FebsConstant.TOKEN_CACHE_PREFIX + token.getToken() + StringPool.DOT + ip, token.getToken(), properties.getShiro().getJwtTimeOut() * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>返回前端数据包括:</p><p>1.token：token；</p><p>2.exipreTime：token过期时间；</p><p>3.roles：用户角色；</p><p>4.permissions：用户权限；</p><p>5.config：用户前端系统的个性化配置；</p><p>6.user：用户信息（不包括密码）。</p><p>比如，当scott登录成功后，接口返回数据如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"permissions"</span>: [</span><br><span class="line">            <span class="string">"user:view"</span>,</span><br><span class="line">            <span class="string">"dept:add"</span>,</span><br><span class="line">            <span class="string">"job:export"</span>,</span><br><span class="line">            <span class="string">"role:add"</span>,</span><br><span class="line">            <span class="string">"weather:view"</span>,</span><br><span class="line">            <span class="string">"dict:add"</span>,</span><br><span class="line">            <span class="string">"role:export"</span>,</span><br><span class="line">            <span class="string">"menu:export"</span>,</span><br><span class="line">            <span class="string">"dict:view"</span>,</span><br><span class="line">            <span class="string">"dept:export"</span>,</span><br><span class="line">            <span class="string">"menu:view"</span>,</span><br><span class="line">            <span class="string">"role:view"</span>,</span><br><span class="line">            <span class="string">"user:export"</span>,</span><br><span class="line">            <span class="string">"job:add"</span>,</span><br><span class="line">            <span class="string">"dept:view"</span>,</span><br><span class="line">            <span class="string">"article:view"</span>,</span><br><span class="line">            <span class="string">"log:view"</span>,</span><br><span class="line">            <span class="string">"jobLog:view"</span>,</span><br><span class="line">            <span class="string">"job:view"</span>,</span><br><span class="line">            <span class="string">"menu:add"</span>,</span><br><span class="line">            <span class="string">"redis:view"</span>,</span><br><span class="line">            <span class="string">"log:export"</span>,</span><br><span class="line">            <span class="string">"movie:coming"</span>,</span><br><span class="line">            <span class="string">"movie:hot"</span>,</span><br><span class="line">            <span class="string">"dict:export"</span>,</span><br><span class="line">            <span class="string">"jobLog:export"</span>,</span><br><span class="line">            <span class="string">"user:online"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"roles"</span>: [</span><br><span class="line">            <span class="string">"注册用户"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"exipreTime"</span>: <span class="string">"20190408164521"</span>,</span><br><span class="line">        <span class="attr">"config"</span>: &#123;</span><br><span class="line">            <span class="attr">"userId"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"theme"</span>: <span class="string">"light"</span>,</span><br><span class="line">            <span class="attr">"layout"</span>: <span class="string">"side"</span>,</span><br><span class="line">            <span class="attr">"multiPage"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"fixSiderbar"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"fixHeader"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"color"</span>: <span class="string">"rgb(24, 144, 255)"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">            <span class="attr">"userId"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"username"</span>: <span class="string">"scott"</span>,</span><br><span class="line">            <span class="attr">"password"</span>: <span class="string">"it's a secret"</span>,</span><br><span class="line">            <span class="attr">"deptId"</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">"deptName"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"email"</span>: <span class="string">"scott@qq.com"</span>,</span><br><span class="line">            <span class="attr">"mobile"</span>: <span class="string">"15134627380"</span>,</span><br><span class="line">            <span class="attr">"status"</span>: <span class="string">"1"</span>,</span><br><span class="line">            <span class="attr">"createTime"</span>: <span class="string">"2017-12-30 00:16:39"</span>,</span><br><span class="line">            <span class="attr">"modifyTime"</span>: <span class="string">"2019-01-18 08:59:09"</span>,</span><br><span class="line">            <span class="attr">"lastLoginTime"</span>: <span class="string">"2019-01-23 15:34:28"</span>,</span><br><span class="line">            <span class="attr">"ssex"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"我是scott，嗯嗯"</span>,</span><br><span class="line">            <span class="attr">"avatar"</span>: <span class="string">"gaOngJwsRYRaVAuXXcmB.png"</span>,</span><br><span class="line">            <span class="attr">"roleId"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"roleName"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"sortField"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"sortOrder"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"createTimeFrom"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"createTimeTo"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"YBeNsMJ0ZJm9GLJP1rlO"</span>,</span><br><span class="line">            <span class="attr">"authCacheKey"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"token"</span>: <span class="string">"b25e39b47e774b4a05b3cb1555fc377f209457c3fd339d373d3fca7b1ea8be56fdc6ed05b7ffb0700e7300d242fb83b57b35f45ee1b155b380 50a0671bc7ec54c2f2c5bb1aee0651db69ce657e8ab4cb79c7806209103eda8a3bc96aa043a0144ae3c06a5c549ac168183c37384cf4347e450bf11644d0 62c31ffc3059e63722f849a5de4540b0d1"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"认证成功"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Redis缓存使用"><a href="#Redis缓存使用" class="headerlink" title="Redis缓存使用"></a>Redis缓存使用</h3><p>在系统启动过程中，会执行缓存初始化操作，对应<code>CacheInitRunner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInitRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserManager userManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            List&lt;User&gt; list = <span class="keyword">this</span>.userService.list();</span><br><span class="line">            <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">                userManager.loadUserRedisCache(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadUserRedisCache</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户相关信息添加到 Redis缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUserRedisCache</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存用户</span></span><br><span class="line">    cacheService.saveUser(user.getUsername());</span><br><span class="line">    <span class="comment">// 缓存用户角色</span></span><br><span class="line">    cacheService.saveRoles(user.getUsername());</span><br><span class="line">    <span class="comment">// 缓存用户权限</span></span><br><span class="line">    cacheService.savePermissions(user.getUsername());</span><br><span class="line">    <span class="comment">// 缓存用户个性化配置</span></span><br><span class="line">    cacheService.saveUserConfigs(String.valueOf(user.getUserId()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这一过程缓存了用户信息，用户角色信息，用户权限信息，用户的个性化配置信息，缓存的具体key，value可以查看上述方法的源码。通过这些缓存，可以一定程度减轻数据库压力。</p><p>为了确保缓存数据和数据库数据的一致性，我们必须在相应的增删改方法中对缓存进行相应的操作。比如在更新用户后，我们必须更新相应的缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新将用户信息，用户角色信息，用户权限信息 加载到 redis中</span></span><br><span class="line">    cacheService.saveUser(user.getUsername());</span><br><span class="line">    cacheService.saveRoles(user.getUsername());</span><br><span class="line">    cacheService.savePermissions(user.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note danger"><p>总而言之，由于我们在启动系统的时候缓存了用户信息，用户角色信息，用户权限信息，用户的个性化配置信息，之后凡是涉及到用户，用户角色，用户权限和用户个性化配置的相关增删改操作都应该及时更新相应的缓存。</p></div><h3 id="动态路由构建"><a href="#动态路由构建" class="headerlink" title="动态路由构建"></a>动态路由构建</h3><p>不同的用户拥有不同的角色，不同的角色对应不同的菜单权限，所以我们需要通过用户查询出对应的菜单列表，然后将列表构建成前端需要的路由（前端根据路由信息构建相应的菜单）。</p><p>获取用户路由的方法为<code>UserManage#getUserRouters</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户名构建 Vue路由</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 路由集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;VueRouter&lt;Menu&gt;&gt; getUserRouters(String username) &#123;</span><br><span class="line">    List&lt;VueRouter&lt;Menu&gt;&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Menu&gt; menus = <span class="keyword">this</span>.menuService.findUserMenus(username);</span><br><span class="line">    menus.forEach(menu -&gt; &#123;</span><br><span class="line">        VueRouter&lt;Menu&gt; route = <span class="keyword">new</span> VueRouter&lt;&gt;();</span><br><span class="line">        route.setId(menu.getMenuId().toString());</span><br><span class="line">        route.setParentId(menu.getParentId().toString());</span><br><span class="line">        route.setIcon(menu.getIcon());</span><br><span class="line">        route.setPath(menu.getPath());</span><br><span class="line">        route.setComponent(menu.getComponent());</span><br><span class="line">        route.setName(menu.getMenuName());</span><br><span class="line">        route.setMeta(<span class="keyword">new</span> RouterMeta(<span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">        routes.add(route);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> TreeUtil.buildVueRouter(routes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>比如用户mrbird对应的前端路由为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"/"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"主页"</span>,</span><br><span class="line">        <span class="attr">"component"</span>: <span class="string">"MenuView"</span>,</span><br><span class="line">        <span class="attr">"icon"</span>: <span class="string">"none"</span>,</span><br><span class="line">        <span class="attr">"redirect"</span>: <span class="string">"/home"</span>,</span><br><span class="line">        <span class="attr">"children"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/home"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"系统主页"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"HomePageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"home"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">"isShow"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/system"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"系统管理"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"PageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"appstore-o"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/system/user"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"用户管理"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"system/user/User"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/system/role"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"角色管理"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"system/role/Role"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/system/menu"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"菜单管理"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"system/menu/Menu"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/system/dept"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"部门管理"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"system/dept/Dept"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/system/dict"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"字典管理"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"system/dict/Dict"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/monitor"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"系统监控"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"PageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"dashboard"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/monitor/online"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"在线用户"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"monitor/Online"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/monitor/systemlog"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"系统日志"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"monitor/SystemLog"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/monitor/redis/info"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"Redis监控"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"monitor/RedisInfo"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/monitor/httptrace"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"请求追踪"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"monitor/Httptrace"</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/monitor/system"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"系统信息"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"EmptyPageView"</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">"children"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"path"</span>: <span class="string">"/monitor/system/jvminfo"</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: <span class="string">"JVM信息"</span>,</span><br><span class="line">                                <span class="attr">"component"</span>: <span class="string">"monitor/JvmInfo"</span>,</span><br><span class="line">                                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"path"</span>: <span class="string">"/monitor/system/tomcatinfo"</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: <span class="string">"Tomcat信息"</span>,</span><br><span class="line">                                <span class="attr">"component"</span>: <span class="string">"monitor/TomcatInfo"</span>,</span><br><span class="line">                                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"path"</span>: <span class="string">"/monitor/system/info"</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: <span class="string">"服务器信息"</span>,</span><br><span class="line">                                <span class="attr">"component"</span>: <span class="string">"monitor/SystemInfo"</span>,</span><br><span class="line">                                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/job"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"任务调度"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"PageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"clock-circle-o"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/job/job"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"定时任务"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"quartz/job/Job"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/job/log"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"调度日志"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"quartz/log/JobLog"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/web"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"网络资源"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"PageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"compass"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/web/weather"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"天气查询"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"web/Weather"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/web/dailyArticle"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"每日一文"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"web/DailyArticle"</span>,</span><br><span class="line">                        <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/web/movie"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"影视资讯"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"EmptyPageView"</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">"children"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"path"</span>: <span class="string">"/web/movie/hot"</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: <span class="string">"正在热映"</span>,</span><br><span class="line">                                <span class="attr">"component"</span>: <span class="string">"web/MovieHot"</span>,</span><br><span class="line">                                <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"path"</span>: <span class="string">"/web/movie/coming"</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: <span class="string">"即将上映"</span>,</span><br><span class="line">                                <span class="attr">"component"</span>: <span class="string">"web/MovieComing"</span>,</span><br><span class="line">                                <span class="attr">"icon"</span>: <span class="string">""</span>,</span><br><span class="line">                                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/others"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"其他模块"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"PageView"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"coffee"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"children"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"/others/excel"</span>,</span><br><span class="line">                        <span class="attr">"name"</span>: <span class="string">"导入导出"</span>,</span><br><span class="line">                        <span class="attr">"component"</span>: <span class="string">"others/Excel"</span>,</span><br><span class="line">                        <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                            <span class="attr">"closeable"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"path"</span>: <span class="string">"/profile"</span>,</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"个人中心"</span>,</span><br><span class="line">                <span class="attr">"component"</span>: <span class="string">"personal/Profile"</span>,</span><br><span class="line">                <span class="attr">"icon"</span>: <span class="string">"none"</span>,</span><br><span class="line">                <span class="attr">"meta"</span>: &#123;</span><br><span class="line">                    <span class="attr">"closeable"</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">"isShow"</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"*"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"404"</span>,</span><br><span class="line">        <span class="attr">"component"</span>: <span class="string">"error/404"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>关于Vue Router可以参考：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a>。</p><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>我们可以在Controller的方法上通过Shiro相关的权限注解进行权限控制，比如下面这个方法只有当用户拥有<code>user:add</code>权限才能访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"user:add"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(@Valid User user)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当用户没有<code>user:add</code>权限时，系统将抛出<code>UnauthorizedException</code>异常，由<code>GlobalExceptionHandler</code>捕获，返回403状态码。</p><p>更多Shiro提供的权限注解可以参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前Subject已经通过login进行了身份验证；即Subject.isAuthenticated()返回true。</span></span><br><span class="line"><span class="meta">@RequiresAuthentication</span>  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 表示当前Subject已经身份验证或者通过记住我登录的。</span></span><br><span class="line"><span class="meta">@RequiresUser</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前Subject没有身份验证或通过记住我登录过，即是游客身份。</span></span><br><span class="line"><span class="meta">@RequiresGuest</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前Subject需要角色admin和user。  </span></span><br><span class="line"><span class="meta">@RequiresRoles</span>(value=&#123;<span class="string">"admin"</span>, <span class="string">"user"</span>&#125;, logical= Logical.AND)  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前Subject需要权限user:a或user:b。</span></span><br><span class="line"><span class="meta">@RequiresPermissions</span> (value=&#123;<span class="string">"user:a"</span>, <span class="string">"user:b"</span>&#125;, logical= Logical.OR)</span><br></pre></td></tr></table></figure><p></p><h3 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h3><p>多数据源采用的是MyBatis Plus提供的方案：<a href="https://mp.baomidou.com/guide/dynamic-datasource.html" target="_blank" rel="noopener">https://mp.baomidou.com/guide/dynamic-datasource.html</a></p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>目前只有后端代码生成器，采用的是MyBatis Plus提供的方案，对应源码<code>cc.mrbird.febs.common.generator.CodeGenerator</code>，执行其main方法，然后输入表名，就可以生成相应的domain、dao、service、controller、mapper.xml。</p><h3 id="Excel导入导出"><a href="#Excel导入导出" class="headerlink" title="Excel导入导出"></a>Excel导入导出</h3><p>Excel导入导出使用的插件为：<a href="https://gitee.com/wuwenze/ExcelKit" target="_blank" rel="noopener">https://gitee.com/wuwenze/ExcelKit</a>，具体操作规则可以仔细阅读这个项目的Readme.md</p><h3 id="统一参数校验"><a href="#统一参数校验" class="headerlink" title="统一参数校验"></a>统一参数校验</h3><p>统一参数校验可以参考我的博客：<a href="https://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html">Spring Boot配合Hibernate Validator参数校验</a>。</p><h3 id="SQL打印"><a href="#SQL打印" class="headerlink" title="SQL打印"></a>SQL打印</h3><p>SQL打印采用的插件为<a href="https://p6spy.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">p6spy</a>，要开启p6spy的SQL打印功能，只需将配置文件application.yml中的<code>spring.datasource.dynamic.p6spy</code>改为<code>true</code>即可。</p><p>在p6spy.properties文件中可以配置打印规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 使用日志系统记录 sql</span><br><span class="line">appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=cc.mrbird.febs.common.config.P6spySqlFormatConfig</span><br><span class="line"># 是否开启慢 SQL记录</span><br><span class="line">outagedetection=true</span><br><span class="line"># 慢 SQL记录标准 2 秒</span><br><span class="line">outagedetectioninterval=2</span><br><span class="line"># 开启过滤</span><br><span class="line">filter=true</span><br><span class="line"># 包含 QRTZ的不打印</span><br><span class="line">exclude=QRTZ</span><br></pre></td></tr></table></figure><p></p><p>SQL打印效果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2019-04-08 15:29:50 | INFO  | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:50 | 耗时 73 ms | SQL 语句：</span><br><span class="line">UPDATE t_user SET last_login_time=&apos;2019-04-08T15:29:50.724+0800&apos; WHERE username = &apos;mrbird&apos;;</span><br><span class="line">2019-04-08 15:29:50 | INFO  | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:50 | 耗时 0 ms | SQL 语句：</span><br><span class="line">SELECT USER_ID,username,password,dept_id,email,mobile,status,create_time,modify_time,last_login_time,ssex,description,avatar FROM t_user WHERE username = &apos;mrbird&apos;;</span><br><span class="line">2019-04-08 15:29:52 | INFO  | http-nio-9527-exec-1 | p6spy | 2019-04-08 15:29:52 | 耗时 489 ms | SQL 语句：</span><br><span class="line">INSERT INTO t_login_log ( username, login_time, location, ip ) VALUES ( &apos;mrbird&apos;, &apos;2019-04-08T15:29:50.874+0800&apos;, &apos;&apos;, &apos;127.0.0.1&apos; );</span><br><span class="line">2019-04-08 15:45:20 | INFO  | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:20 | 耗时 1 ms | SQL 语句：</span><br><span class="line">UPDATE t_user SET last_login_time=&apos;2019-04-08T15:45:20.193+0800&apos; WHERE username = &apos;scott&apos;;</span><br><span class="line">2019-04-08 15:45:20 | INFO  | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:20 | 耗时 0 ms | SQL 语句：</span><br><span class="line">SELECT USER_ID,username,password,dept_id,email,mobile,status,create_time,modify_time,last_login_time,ssex,description,avatar FROM t_user WHERE username = &apos;scott&apos;;</span><br><span class="line">2019-04-08 15:45:21 | INFO  | http-nio-9527-exec-7 | p6spy | 2019-04-08 15:45:21 | 耗时 89 ms | SQL 语句：</span><br><span class="line">INSERT INTO t_login_log ( username, login_time, location, ip ) VALUES ( &apos;scott&apos;, &apos;2019-04-08T15:45:20.466+0800&apos;, &apos;&apos;, &apos;127.0.0.1&apos; );</span><br></pre></td></tr></table></figure><div class="note info"><p>开启这个功能方便我们开发调试，生产环境最好关闭这个功能，因为它在一定程度上会造成性能耗损。</p></div><p>更多p6psy的配置可以参考：<a href="https://p6spy.readthedocs.io/en/latest/configandusage.html" target="_blank" rel="noopener">https://p6spy.readthedocs.io/en/latest/configandusage.html</a></p><h3 id="AOP记录操作日志"><a href="#AOP记录操作日志" class="headerlink" title="AOP记录操作日志"></a>AOP记录操作日志</h3><p>具体可以参考我的博客：<a href="https://mrbird.cc/Spring-Boot-AOP%20log.html">Spring Boot AOP记录用户操作日志</a>。</p><p>记录操作日志的过程可以改为异步的方式，这样不会造成接口性能损耗，可以参考我的博客：<a href="https://mrbird.cc/Spring-Boot-Async.html">Spring Boot 中的异步调用</a>。</p><h3 id="接口限流"><a href="#接口限流" class="headerlink" title="接口限流"></a>接口限流</h3><p>项目中<code>@Limit</code>注解可以实现接口的限流。即规定一段时间内最多可以访问该接口的次数，超过这个次数则抛出<code>LimitAccessException</code>异常。<code>@Limit</code>注解如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cc.mrbird.common.domain.LimitType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Limit &#123;</span><br><span class="line">    <span class="comment">// 资源名称，用于描述接口功能</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 资源 key</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// key prefix</span></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 时间的，单位秒</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">period</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 限制访问次数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 限制类型</span></span><br><span class="line">    <span class="function">LimitType <span class="title">limitType</span><span class="params">()</span> <span class="keyword">default</span> LimitType.CUSTOMER</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中，limitType包含传统类型限流和根据IP限流，其为枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> LimitType &#123;</span><br><span class="line">    <span class="comment">// 传统类型</span></span><br><span class="line">    CUSTOMER,</span><br><span class="line">    <span class="comment">// 根据 IP 限制</span></span><br><span class="line">    IP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面举个使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cc.mrbird.common.annotation.Limit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger ATOMIC_INTEGER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Limit</span>(key = <span class="string">"test"</span>, period = <span class="number">600</span>, count = <span class="number">10</span>, name = <span class="string">"resource"</span>, prefix = <span class="string">"limit"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">testLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ATOMIC_INTEGER.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面配置表示使用传统限流的方式，testLimiter方法在600秒内最多只能访问10次。当600秒内第11次访问该接口时，接口将抛出<code>LimitAccessException</code>异常。</p><h3 id="Shiro教程"><a href="#Shiro教程" class="headerlink" title="Shiro教程"></a>Shiro教程</h3><ol><li><p><a href="https://mrbird.cc/Apache%20Shiro%E7%AE%80%E4%BB%8B.html">Apache Shiro简介</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-shiro%20Authentication.html">Spring Boot Shiro用户认证</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-Shiro%20Remember-Me.html">Spring Boot Shiro 添加记住我功能</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-Shiro%20Authorization.html">Spring Boot Shiro权限控制</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-Shiro%20cache.html">Spring Boot Shiro中使用缓存</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-Themeleaf%20Shiro%20tag.html">Spring Boot Thymeleaf中使用Shiro标签</a></p></li><li><p><a href="https://mrbird.cc/Spring-Boot-Shiro%20session.html">Spring Boot Shiro在线会话管理</a></p></li></ol><h3 id="Shiro如何整合JWT"><a href="#Shiro如何整合JWT" class="headerlink" title="Shiro如何整合JWT"></a>Shiro如何整合JWT</h3><p>Shiro如何整合JWT可以参考：<a href="https://gitlab.com/wuyouzhuguli/shiro_jwt" target="_blank" rel="noopener">https://gitlab.com/wuyouzhuguli/shiro_jwt</a></p><p>为了简化过程，例子没有使用数据库和Redis，在内存中模拟了两个用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟两个用户</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;User&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">users</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 模拟两个用户：</span></span><br><span class="line">    <span class="comment">// 1. 用户名 admin，密码 123456，角色 admin（管理员），权限 "user:add"，"user:view"</span></span><br><span class="line">    <span class="comment">// 1. 用户名 scott，密码 123456，角色 regist（注册用户），权限 "user:view"</span></span><br><span class="line">    users.add(<span class="keyword">new</span> User(</span><br><span class="line">            <span class="string">"admin"</span>,</span><br><span class="line">            <span class="string">"bfc62b3f67a4c3e57df84dad8cc48a3b"</span>,</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;&gt;(Collections.singletonList(<span class="string">"admin"</span>)),</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"user:add"</span>, <span class="string">"user:view"</span>))));</span><br><span class="line">    users.add(<span class="keyword">new</span> User(</span><br><span class="line">            <span class="string">"scott"</span>,</span><br><span class="line">            <span class="string">"11bd73355c7bbbac151e4e4f943e59be"</span>,</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;&gt;(Collections.singletonList(<span class="string">"regist"</span>)),</span><br><span class="line">            <span class="keyword">new</span> HashSet&lt;&gt;(Collections.singletonList(<span class="string">"user:view"</span>))));</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以使用PostMan进行接口测试。</p><h2 id="前端项目介绍"><a href="#前端项目介绍" class="headerlink" title="前端项目介绍"></a>前端项目介绍</h2><h3 id="项目结构-1"><a href="#项目结构-1" class="headerlink" title="项目结构"></a>项目结构</h3><p>项目机构如下图所示：</p><p><img src="img/febsvue/2019-04-08_185510.png" alt="2019-04-08_185510.png"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>在用户登录成功后，项目会通过Vuex和localstorage存储一些数据供项目全局使用。</p><p>正如前面所说，当用户登录成功后，后端会返回如下数据：</p><ol><li><p>token：token；</p></li><li><p>exipreTime：token过期时间；</p></li><li><p>roles：用户角色；</p></li><li><p>permissions：用户权限；</p></li><li><p>config：用户前端系统的个性化配置；</p></li><li><p>user：用户信息（不包括密码）。</p></li></ol><p>在src/views/login/Login.vue文件中你会看到如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...mapMutations(&#123;</span><br><span class="line">  setToken: <span class="string">'account/setToken'</span>,</span><br><span class="line">  setExpireTime: <span class="string">'account/setExpireTime'</span>,</span><br><span class="line">  setPermissions: <span class="string">'account/setPermissions'</span>,</span><br><span class="line">  setRoles: <span class="string">'account/setRoles'</span>,</span><br><span class="line">  setUser: <span class="string">'account/setUser'</span>,</span><br><span class="line">  setTheme: <span class="string">'setting/setTheme'</span>,</span><br><span class="line">  setLayout: <span class="string">'setting/setLayout'</span>,</span><br><span class="line">  setMultipage: <span class="string">'setting/setMultipage'</span>,</span><br><span class="line">  fixSiderbar: <span class="string">'setting/fixSiderbar'</span>,</span><br><span class="line">  fixHeader: <span class="string">'setting/fixHeader'</span>,</span><br><span class="line">  setColor: <span class="string">'setting/setColor'</span></span><br><span class="line">&#125;),</span><br><span class="line">saveLoginData (data) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setToken(data.token)</span><br><span class="line">  <span class="keyword">this</span>.setExpireTime(data.exipreTime)</span><br><span class="line">  <span class="keyword">this</span>.setUser(data.user)</span><br><span class="line">  <span class="keyword">this</span>.setPermissions(data.permissions)</span><br><span class="line">  <span class="keyword">this</span>.setRoles(data.roles)</span><br><span class="line">  <span class="keyword">this</span>.setTheme(data.config.theme)</span><br><span class="line">  <span class="keyword">this</span>.setLayout(data.config.layout)</span><br><span class="line">  <span class="keyword">this</span>.setMultipage(data.config.multiPage === <span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">this</span>.fixSiderbar(data.config.fixSiderbar === <span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">this</span>.fixHeader(data.config.fixHeader === <span class="string">'1'</span>)</span><br><span class="line">  <span class="keyword">this</span>.setColor(data.config.color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这将把登录接口返回的数据存储到Vuex和浏览器的localstorage中。</p><p>存储Token的原因是，后续需要认证的请求，都会在请求头中携带这个Token；存储ExpireTime的原因是为了优化认证过期时的用户体验；存储用户信息的原因是为了供个人中心和系统主页使用；存储角色和权限是为了判断页面按钮渲染与否；存储用户个性化配置的原因是为了通过这些配置渲染不同的系统界面。</p><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><p>路由导航守卫代码位置：frontend/src/router/index.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">'/login'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> asyncRouter</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导航守卫，渲染动态路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (whiteList.indexOf(to.path) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> token = db.get(<span class="string">'USER_TOKEN'</span>)</span><br><span class="line">  <span class="keyword">let</span> user = db.get(<span class="string">'USER'</span>)</span><br><span class="line">  <span class="keyword">let</span> userRouter = get(<span class="string">'USER_ROUTER'</span>)</span><br><span class="line">  <span class="keyword">if</span> (token.length &amp;&amp; user) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!asyncRouter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!userRouter) &#123;</span><br><span class="line">        request.get(<span class="string">`menu/<span class="subst">$&#123;user.username&#125;</span>`</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          asyncRouter = res.data</span><br><span class="line">          save(<span class="string">'USER_ROUTER'</span>, asyncRouter)</span><br><span class="line">          go(to, next)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        asyncRouter = userRouter</span><br><span class="line">        go(to, next)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span> (<span class="params">to, next</span>) </span>&#123;</span><br><span class="line">  asyncRouter = filterAsyncRouter(asyncRouter)</span><br><span class="line">  router.addRoutes(asyncRouter)</span><br><span class="line">  next(&#123;...to, <span class="attr">replace</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p>主要逻辑分为下面几步：</p><ol><li><p>判断要跳转的路由地址是否在路由白名单内，是的话放行，不是的话进行第2步；</p></li><li><p>从内存中获取token和用户信息，如果存在则进行第3步，不存在跳转到登录页；</p></li><li><p>判断动态路由信息是否存在，存在则放行，不存在则进行第4步；</p></li><li><p>判断用户路由是否已经加载，是的话将用户路由赋值给动态路由，并执行路由添加操作，然后跳转；如果用户路由不存在，则执行第5步；</p></li><li><p>根据用户名从后台获取用户路由信息，并将其保存到内存中，再执行路由添加操作，然后跳转。</p></li></ol><h3 id="权限控制-1"><a href="#权限控制-1" class="headerlink" title="权限控制"></a>权限控制</h3><p>在前端页面中，我们已经实现了通过不同用户获取不同的路由，以此渲染出不同的菜单列表功能，此外页面上的操作按钮也必须进行权限控制。</p><p>正如前面所述，在登录成功后，系统会把用户的角色和权限信息存储到了内存中，所以我们可以通过这些信息结合<a href="https://cn.vuejs.org/v2/guide/custom-directive.html" target="_blank" rel="noopener"> 自定义Vue指令 </a>的方式来实现按钮的权限控制。</p><p>目前支持的和权限相关的Vue指令有：</p><table><thead><tr><th>指令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>v-hasPermission</td><td>当用户拥有列出的权限的时候，渲染该元素</td><td><code>&lt;template v-hasPermission=&quot;&#39;user:add&#39;,&#39;user:update&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;</code></td></tr><tr><td>v-hasAnyPermission</td><td>当用户拥有列出的任意一项权限的时候，渲染该元素</td><td><code>&lt;template v-hasAnyPermission=&quot;&#39;user:add&#39;,&#39;user:update&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;</code></td></tr><tr><td>v-hasRole</td><td>当用户拥有列出的角色的时候，渲染该元素</td><td><code>&lt;template v-hasRole=&quot;&#39;admin&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;</code></td></tr><tr><td>v-hasAnyRole</td><td>当用户拥有列出的任意一个角色的时候，渲染该元素</td><td><code>&lt;template v-hasAnyRole=&quot;&#39;admin&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/template&gt;</code></td></tr><tr><td>hasNoPermission</td><td>当用户没有列出的权限的时候，渲染该元素</td><td><code>&lt;template v-hasNoPermission=&quot;&#39;user:add&#39;,&#39;register&#39;&quot;&gt;&lt;span&gt;无操作权限&lt;/span&gt;&lt;/template&gt;</code></td></tr></tbody></table><p>以<code>v-hasPermission=&quot;user:add&quot;</code>为例，详细介绍下自定义权限Vue指令的实现过程：</p><ol><li><p>在src/utils/permissionDirect.js中定义如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> hasPermission = &#123;</span><br><span class="line">  install (Vue) &#123;</span><br><span class="line">    Vue.directive(<span class="string">'hasPermission'</span>, &#123;</span><br><span class="line">      bind (el, binding, vnode) &#123;</span><br><span class="line">        <span class="keyword">let</span> permissions = vnode.context.$store.state.account.permissions</span><br><span class="line">        <span class="keyword">let</span> value = binding.value.split(<span class="string">','</span>)</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> value) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!permissions.includes(v)) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!el.parentNode) &#123;</span><br><span class="line">            el.style.display = <span class="string">'none'</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            el.parentNode.removeChild(el)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们从Vuex中获取了用户所拥有的权限，然后判断这些权限中是否包含<code>user:add</code>，如果不包含，则将对应的元素（el）移除或者隐藏。所以当用户没有<code>user:add</code>权限时，下面的按钮将不会被渲染在页面上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-hasPermission</span>=<span class="string">"'user:add'"</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>新增用户<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>要让自定义Vue指令生效，还需要在src/utils/install.js中将其添加到Plugins列表。</p></li></ol><h3 id="Axios封装"><a href="#Axios封装" class="headerlink" title="Axios封装"></a>Axios封装</h3><p>项目使用Axios插件来发送HTTP请求，并对它进行了封装（frontend/src/utils/request.js），这里主要讲述下request.js中主要逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一配置</span></span><br><span class="line"><span class="keyword">let</span> FEBS_REQUEST = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'http://127.0.0.1:9527/'</span>,</span><br><span class="line">  responseType: <span class="string">'json'</span>,</span><br><span class="line">  validateStatus (status) &#123;</span><br><span class="line">    <span class="comment">// 200 外的状态码都认定为失败</span></span><br><span class="line">    <span class="keyword">return</span> status === <span class="number">200</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这段代码对请求进行了统一配置，baseURL定义了后端地址的基础路径，responseType定义了响应数据类型为JSON，只有状态码为200时才认定请求成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截请求</span></span><br><span class="line">FEBS_REQUEST.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> expireTime = store.state.account.expireTime</span><br><span class="line">  <span class="keyword">let</span> now = moment().format(<span class="string">'YYYYMMDDHHmmss'</span>)</span><br><span class="line">  <span class="comment">// 让token早10秒种过期，提升“请重新登录”弹窗体验</span></span><br><span class="line">  <span class="keyword">if</span> (now - expireTime &gt;= <span class="number">-10</span>) &#123;</span><br><span class="line">    Modal.error(&#123;</span><br><span class="line">      title: <span class="string">'登录已过期'</span>,</span><br><span class="line">      content: <span class="string">'很抱歉，登录已过期，请重新登录'</span>,</span><br><span class="line">      okText: <span class="string">'重新登录'</span>,</span><br><span class="line">      mask: <span class="literal">false</span>,</span><br><span class="line">      onOk: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    	  <span class="comment">// 为什么不直接跳转到登录页呢？那是因为Vue没有提供清空路由的方法，只能通过刷新页面的方式</span></span><br><span class="line">    	  <span class="comment">// 来清除之前动态添加的路由信息。</span></span><br><span class="line">          db.clear()</span><br><span class="line">          location.reload()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有 token就带上</span></span><br><span class="line">  <span class="keyword">if</span> (store.state.account.token) &#123;</span><br><span class="line">    config.headers.Authentication = store.state.account.token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在Axios的前置拦截中，我们首先判断了token是否已经过期，如果过期了则清空在登录时保存的数据，并且刷新页面。这时候通过路由导航守卫，页面会被重定向到登录页面，引导用户重新登录。</p><p>如果token没有过期，则在请求头上带上token信息。<code>headers.Authentication</code>和后端代码中的TOKEN名称相对应：</p><p><img src="img/febsvue/QQ截图20190409101831.png" alt="QQ截图20190409101831.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截响应</span></span><br><span class="line">FEBS_REQUEST.interceptors.response.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">    <span class="keyword">let</span> errorMessage = error.response.data === <span class="literal">null</span> ? <span class="string">'系统内部异常，请联系网站管理员'</span> : error.response.data.message</span><br><span class="line">    <span class="keyword">switch</span> (error.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">        notification.error(&#123;</span><br><span class="line">          message: <span class="string">'系统提示'</span>,</span><br><span class="line">          description: <span class="string">'很抱歉，资源未找到'</span>,</span><br><span class="line">          duration: <span class="number">4</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">        notification.warn(&#123;</span><br><span class="line">          message: <span class="string">'系统提示'</span>,</span><br><span class="line">          description: <span class="string">'很抱歉，您无法访问该资源，可能是因为没有相应权限或者登录已失效'</span>,</span><br><span class="line">          duration: <span class="number">4</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        notification.error(&#123;</span><br><span class="line">          message: <span class="string">'系统提示'</span>,</span><br><span class="line">          description: errorMessage,</span><br><span class="line">          duration: <span class="number">4</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中我们实现了异常响应的统一处理，根据不同的状态码给予不同的提示信息。</p><p>此外，项目还对各种HTTP请求进行了封装，下面一一列举出它们的用法：</p><p><strong>GET请求</strong></p><p>方式一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$get(<span class="string">'user'</span>, &#123;</span><br><span class="line">   ...params</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>因为我们在前面已经定义了后端地址的基础路径，所以上面这个请求的实际地址为：<a href="http://127.0.0.1:9527/user。" target="_blank" rel="noopener">http://127.0.0.1:9527/user。</a></p><p>在前面我们已经对异常响应进行统一处理，当然你也可以通过catch来覆盖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$get(<span class="string">'user'</span>, &#123;</span><br><span class="line">   ...params</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">   alert(<span class="string">'出错啦'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方式二（路径传参）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$get(<span class="string">`menu/<span class="subst">$&#123;user.username&#125;</span>`</span>).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>方式三：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$get(<span class="string">`user?username=<span class="subst">$&#123;user.username&#125;</span>`</span>).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>POST请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$post(<span class="string">'user'</span>, &#123;</span><br><span class="line">   ...params</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>PUT请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$put(<span class="string">'user'</span>, &#123;</span><br><span class="line">   ...params</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>DELETE请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$<span class="keyword">delete</span>(<span class="string">'user/$&#123;user.userId&#125;'</span>).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p><strong>下载文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$download(<span class="string">'file'</span>, &#123; ...params &#125;, <span class="string">'xxx.xx'</span>)</span><br></pre></td></tr></table></figure><p></p><p>xxx.xx为下载的文件名，比如下载xlsx文件的话为 Excel文件.xlsx，后端接口返回数据流即可。</p><p><strong>上传文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData($(<span class="string">"#form"</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">this</span>.$upload(<span class="string">'upload'</span>, formData).then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(r)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>后端以<code>MultipartFile</code>接收文件即可。</p><h3 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h3><p>在build/webpack.base.conf.js中，我们定义了一些路径变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    ...</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'~'</span>: resolve(<span class="string">'src/components'</span>),</span><br><span class="line">      <span class="string">'utils'</span>: resolve(<span class="string">'src/utils'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>比如<code>~</code>代表<code>src/components</code>路径，在项目中，如果要引入<code>src/components/test.vue</code>只需要这样做即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ~<span class="regexp">/test.vue</span></span><br></pre></td></tr></table></figure><p></p><p>当然，你也可以使用相对路径和绝对路径，而不使用这些变量。</p><h3 id="第三方组件介绍"><a href="#第三方组件介绍" class="headerlink" title="第三方组件介绍"></a>第三方组件介绍</h3><p><a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a>已经提供了非常丰富的组件，除此之外，项目里使用的图表插件为：<a href="https://apexcharts.com/vue-chart-demos/line-charts/basic/" target="_blank" rel="noopener">apexcharts.js</a>，其官方文档提供了很多示例，这里就不赘述了。</p><h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><p>相信正在阅读文档的你十有八九是一名后端开发者，可能对前端特别是对Vue不太熟悉，这里给出几点改造frontend的建议：</p><ol><li><p>要有一定的ES6语法基础，可以参考<a href="https://mrbird.cc/ES2015-Learn-Note.html"> ES6学习笔记 </a>，如果要系统学习ES6，推荐阮一峰的：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener"> ECMAScript 6 入门 </a>。</p></li><li><p>Vue的官方文档还是挺详细的，建议仔细阅读，我在学习Vue的时候也做了一些笔记，可以参考：<a href="https://mrbird.cc/Vue-Learn-Note.html">https://mrbird.cc/Vue-Learn-Note.html</a>。Vue的学习路线：Vue基础语法 -&gt; Vuex -&gt; Vue Router。</p></li><li><p>前端组件用的是<a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener">Ant Design Vue</a>，所以在使用它提供的组件的时候，多阅读它的使用文档。</p></li></ol><h2 id="开发示例"><a href="#开发示例" class="headerlink" title="开发示例"></a>开发示例</h2><h3 id="新建一个页面"><a href="#新建一个页面" class="headerlink" title="新建一个页面"></a>新建一个页面</h3><p>在frontend工程的src/views下新建一个test目录，在该目录下新建一个test.vue文件： <img src="img/febsvue/QQ截图20190409133947.png" alt="QQ截图20190409133947.png"></p><p>内容如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>&#123;&#123;hello&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">'test'</span>,</span></span><br><span class="line"><span class="undefined">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      hello: <span class="string">'hello world'</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#42b984</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span>: 1<span class="selector-class">.1rem</span>;</span></span><br><span class="line"><span class="undefined">    font-weight: 600;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>启动项目，使用管理员账号登录，然后在菜单管理中新建一个菜单：</p><p><img src="img/febsvue/20190409134916.png" alt="QQ截图20190409134916.png"></p><ol><li><p>菜单URL：这里填写/test的话，在访问这个页面的时候，浏览器地址栏为<a href="http://localhost:8081/#/test" target="_blank" rel="noopener">http://localhost:8081/#/test</a>，只要确保这个值不重复即可；</p></li><li><p>组件地址：对应要渲染的Vue组件地址，在路由导航守卫中有如下一段代码：</p><p><img src="img/febsvue/20190409135425.png" alt="QQ截图20190409135425.png"></p><p>所以这里填test/test，对应<code>@/views/test/test.vue</code>组件。</p></li><li><p>相关权限：访问这个页面需要<code>test:view</code>权限。</p></li></ol><p>点击确定后，这个菜单就被建好了：</p><p><img src="img/febsvue/20190409135740.png" alt="QQ截图20190409135740.png"></p><p>接着修改管理员角色，将刚刚新建的菜单授权给管理员：</p><p><img src="img/febsvue/QQ截图20190409141220.png" alt="QQ截图20190409141220.png"></p><p>点击确定修改后，重新登录系统：</p><p><img src="img/febsvue/asdfasdfasfdasdf.png" alt="QQ截图20190409141410.png"></p><h3 id="如何新建一个多级菜单"><a href="#如何新建一个多级菜单" class="headerlink" title="如何新建一个多级菜单"></a>如何新建一个多级菜单</h3><p>在新增多级菜单前，先了解下系统中的一个约定：在一个多级菜单中，<strong>顶级菜单对应的组件为PageView，末级菜单对应的组件为需要渲染的页面组件，剩下的（非顶级，非末级的中间菜单对应的组件为EmptyPageView）</strong>。</p><p>我们来建一个四级菜单，首先新增一个顶级菜单：</p><p><img src="img/febsvue/QQ截图20190409142251.png" alt="QQ截图20190409142251.png"></p><p>因为是顶级菜单，所以对应组件填PageView。</p><p>接着新增第二级菜单：</p><p><img src="img/febsvue/QQ截图20190409142642.png" alt="QQ截图20190409142642.png"></p><p>因为它数据中间菜单（非顶级非末级）所以对应组件填EmptyPageView，上级菜单勾选刚刚新建的一级菜单。</p><p>继续新增三级菜单：</p><p><img src="img/febsvue/QQ截图20190409143223.png" alt="QQ截图20190409143223.png"></p><p>因为它也是一个中间菜单，所以对应组件填EmptyPageView，上级菜单勾选刚刚新建的二级菜单。</p><p>最后将我们前面建好的测试页面作为末级，点击测试页面后面的小齿轮按钮，进行修改：</p><p><img src="img/febsvue/QQ截图20190409143905.png" alt="QQ截图20190409143905.png"></p><p>点击确定后一个四级菜单就建好了：</p><p><img src="img/febsvue/QQ截图20190409143943.png" alt="QQ截图20190409143943.png"></p><p>最后一步授权！修改管理员角色：</p><p><img src="img/febsvue/QQ截图20190409144206.png" alt="QQ截图20190409144206.png"></p><p>修改后，重新登录系统：</p><p><img src="img/febsvue/QQ截图20190409144908.png" alt="QQ截图20190409144908.png"></p><p>因为我没有设置排序，所以默认排在最前面了。</p><h3 id="如何隐藏路由"><a href="#如何隐藏路由" class="headerlink" title="如何隐藏路由"></a>如何隐藏路由</h3><p>有的时候，一些路由并不需要渲染成菜单，比如个人中心这类页面。而这些页面一般都是所有用户共有的，所以在后台系统里构建路由的时候写死即可。要隐藏路由只需要将路由meta的isShow属性设置为false即可：</p><p>参考后台代码cc.mrbird.febs.common.utils.TreeUtil：</p><p><img src="img/febsvue/20190409150427.png" alt="QQ截图20190409150427.png"></p><h3 id="如何分配权限"><a href="#如何分配权限" class="headerlink" title="如何分配权限"></a>如何分配权限</h3><p>权限是和角色绑定的，所以要分配权限实际就是对角色的增删改。假如现在要配置一个角色 ——— 系统监控管理员，负责系统监控模块的查看：</p><p><img src="img/febsvue/QQ截图20190409152413.png" alt="QQ截图20190409152413.png"></p><p>然后新增一个用户 ——— yuuki，角色为系统监控管理员：</p><p><img src="img/febsvue/QQ截图20190409152550.png" alt="QQ截图20190409152550.png"></p><p>新建好后，使用yuuki的账号登录：</p><p><img src="img/febsvue/QQ截图20190409153002.png" alt="QQ截图20190409153002.png"></p><p>可以看到，yuuki只有系统监控模块的权限。</p><h3 id="前端如何添加依赖"><a href="#前端如何添加依赖" class="headerlink" title="前端如何添加依赖"></a>前端如何添加依赖</h3><p>在<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a>搜索需要安装的依赖，比如jQuery：</p><p><img src="img/febsvue/QQ截图20190409153227.png" alt="QQ截图20190409153227.png"></p><p>比如我需要安装jQuery 3.3.1版本，只需要在终端输入如下命令即可：</p><p><img src="img/febsvue/QQ截图20190409153710.png" alt="QQ截图20190409153710.png"></p><p>安装好后，在package.json的依赖列表里会多出一个jquery 3.3.1：</p><p><img src="img/febsvue/QQ截图20190409153800.png" alt="QQ截图20190409153800.png"></p><h3 id="如何处理排序"><a href="#如何处理排序" class="headerlink" title="如何处理排序"></a>如何处理排序</h3><p>对于前端来说，需要上送两个参数：</p><ol><li><p>sortField：需要排序的字段；</p></li><li><p>sortOrder：排序规则，ascend或者descend。</p></li></ol><p>对于后端来说，排序主要分为四种情况：</p><ol><li>结果需要分页的，并且是通过xml定义的SQL查询出来的结果：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortUtil.handlePageSort(request, page, <span class="string">"userId"</span>, FebsConstant.ORDER_ASC, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><code>userId</code>和<code>FebsConstant.ORDER_ASC</code>指定了默认的排序规则，即默认按照<code>userId</code>字段升序排序。最后一个参数表示是否需要开启驼峰转下划线，这种情况下不需要，false即可。</p><p>具体可以参考cc.mrbird.febs.system.service.impl.UserServiceImpl#findUserDetail。</p><p>如果不需要指定默认排序规则，使用handlePageSort的重载方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortUtil.handlePageSort(request, page, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>结果需要分页的，并且是通过Mybatis Plus插件查询出来的结果：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortUtil.handlePageSort(request, page, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>这种情况下，最后一个参数值必须为true。</p><p>具体可以参考cc.mrbird.febs.system.service.impl.DictServiceImpl#findDicts。</p><div class="note info"><p>1和2主要区别就是是否需要开启驼峰转下划线。</p></div><ol start="3"><li>结果不需要分页，并且是通过xml定义的SQL查询出来的结果：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortUtil.handleWrapperSort(request, queryWrapper, <span class="string">"orderNum"</span>, FebsConstant.ORDER_ASC, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>具体可以参考：cc.mrbird.febs.system.service.impl.DeptServiceImpl#findDepts</p><ol start="4"><li>结果不需要分页，并且是通过Mybatis Plus插件查询出来的结果：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortUtil.handleWrapperSort(request, queryWrapper, <span class="string">"orderNum"</span>, FebsConstant.ORDER_ASC, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>总之，对于处理排序的方法，第一个参数一定是cc.mrbird.febs.common.domain.QueryRequest。第二个参数如果需要分页，则传递com.baomidou.mybatisplus.extension.plugins.pagination.Page，不需要分页则传递com.baomidou.mybatisplus.core.conditions.query.QueryWrapper。最后一个参数如果查询结果是Mybatis Plus查询出来的结果，则需设置为true，否则为false。</p><h3 id="后端接口测试"><a href="#后端接口测试" class="headerlink" title="后端接口测试"></a>后端接口测试</h3><p>由于后端接口为RESTful接口，所以不能使用浏览器来测试，可以使用PostMan或者Chrome插件RestLet来测试后端接口。文档以PostMan为例。</p><p>因为后台接口大部分都需要用户认证后才能访问，所以在测试之前需要通过登录接口获取一个可用的token。</p><p><img src="img/febsvue/QQ截图20190409161742.png" alt="QQ截图20190409161742.png"></p><p>成功获取到了token。</p><p>测试获取mrbird的前端路由信息：</p><p><img src="img/febsvue/QQ截图20190409161947.png" alt="QQ截图20190409161947.png"></p><p>在Headers设置一个键值对，key为Authentication，value为刚刚获取到的token，发送请求便可以获取到mrbird的路由信息。其他接口测试以此类推。</p><p>如果token填错或者不填：</p><p><img src="img/febsvue/QQ截图20190409162214.png" alt="QQ截图20190409162214.png"></p><p>后端将返回401。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="导入项目编译出错，代码是否不全？"><a href="#导入项目编译出错，代码是否不全？" class="headerlink" title="导入项目编译出错，代码是否不全？"></a>导入项目编译出错，代码是否不全？</h3><p>编辑器安装lombok插件即可。</p><h3 id="导入SQL为何出错？"><a href="#导入SQL为何出错？" class="headerlink" title="导入SQL为何出错？"></a>导入SQL为何出错？</h3><p>MySQL数据库请使用5.7.x版本，不同版本SQL语法有差异。如果你SQL技术过硬可以通过错误信息去修改出错的SQL，更推荐的做法是安装推荐版本的MySQL数据库。</p><h3 id="ip2region是啥玩意，打开怎么乱码？"><a href="#ip2region是啥玩意，打开怎么乱码？" class="headerlink" title="ip2region是啥玩意，打开怎么乱码？"></a>ip2region是啥玩意，打开怎么乱码？</h3><p>通过ip获取地址的开源软件数据库文件，不要直接打开。ip2region地址：<a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region</a>。</p><h2 id="项目缺陷"><a href="#项目缺陷" class="headerlink" title="项目缺陷"></a>项目缺陷</h2><ol><li><p>前端页面不支持移动端（不能自适应）；</p></li><li><p>前端打包后vendor.js较大，通过nginx压缩后在591kb左右，在我的渣渣服务器（1核1G1M）下，访问时间大约为7 - 8秒左右：</p></li></ol><p><img src="img/febsvue/QQ截图20190409162930.png" alt="QQ截图20190409162930.png"></p><p>如果你的服务器带宽够大，或者是部署在公司局域网内的话，这个问题可以忽略。如果要在根源上解决这个问题个人觉得可以从这几个地方入手：</p><ul><li><p>Ant Design采用SVG格式的图标后，导致项目打包体积过大，可以参考官方issue的讨论：<a href="https://github.com/vueComponent/ant-design-vue/issues/325" target="_blank" rel="noopener">https://github.com/vueComponent/ant-design-vue/issues/325</a>和<a href="https://github.com/ant-design/ant-design/issues/12011" target="_blank" rel="noopener">https://github.com/ant-design/ant-design/issues/12011</a>；</p></li><li><p>可以将依赖通过CDN来加载，参考连接：<a href="https://blog.csdn.net/qq_35844177/article/details/78599064" target="_blank" rel="noopener">https://blog.csdn.net/qq_35844177/article/details/78599064</a>；</p></li><li><p>webpack打包配置可能存在可优化的地方。</p></li></ul><p>由于我才疏学浅，前端技能薄弱，所以没能够很好地解决这个问题。欢迎来自五湖四海的能人志士pull request来改善这个问题，感激不尽。</p><p><img src="img/febsvue/QQ图片20190409164403.jpg" alt="QQ图片20190409164403.jpg"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:16 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;FEBS-Vue为&lt;a href=&quot;https://github.com/wuyouzhuguli/FEBS-Shiro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FEBS-Shiro&lt;/a&gt;的前后端分离版本，前端使用Vue全家桶，组件库采用&lt;a href=&quot;https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ant-Design-Vue&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;文档里介绍的示例是在Windows10操作系统下完成的，后端编辑器使用IDEA，前端编辑器使用WebStorm。
    
    </summary>
    
    
      <category term="FEBS" scheme="http://mrbird.cc/tags/FEBS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot WebFlux增删改查样例</title>
    <link href="http://mrbird.cc/Spring-Boot-WebFlux-CRUD.html"/>
    <id>http://mrbird.cc/Spring-Boot-WebFlux-CRUD.html</id>
    <published>2018-12-02T08:00:36.000Z</published>
    <updated>2019-07-12T13:02:30.526Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --><p>在<a href="/Spring-Boot-2-0-WebFlux.html]"> Spring Boot 2.0 WebFlux编程 </a>一节我们大致了解了WebFlux的用法，这节我们将结合Mongo DB在WebFlux的架构下实现增删改查样例。和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>不同的是，我们使用的是Reactive Mongo DB依赖，所有增删改查方法返回值类型为Flux或者Mono。</p><a id="more"></a><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入<code>webflux</code>和<code>reactive mongodb</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>要开启<code>Reactive Mongo DB</code>的相关配置，需要在Spring Boot启动类上添加<code>@EnableReactiveMongoRepositories</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableReactiveMongoRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebfluxApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WebfluxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着在配置文件application.yml里配置Mongo DB连接：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">      database:</span> <span class="string">webflux</span></span><br></pre></td></tr></table></figure><p></p><p>使用的是<code>webflux</code>数据库，所以需要在Mongo DB里新建一个<code>webflux</code>数据库（并创建user文档/表，以供待会使用）：</p><p><img src="img/QQ截图20190404105640.png" alt="QQ截图20190404105640.png"></p><p>创建<code>User</code>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="简单增删改查"><a href="#简单增删改查" class="headerlink" title="简单增删改查"></a>简单增删改查</h2><p>创建<code>UserDao</code>接口，继承自<code>ReactiveMongoRepository</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>不同的是，我们继承的是<code>ReactiveMongoRepository</code>而非<code>MongoRepository</code>，它所提供的方法都是响应式的：</p><p><img src="img/QQ截图20190404110050.png" alt="QQ截图20190404110050.png"></p><p>在<code>UserService</code>里通过<code>UserDao</code>定义简单增删改查方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">deleteUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">                .flatMap(user -&gt; <span class="keyword">this</span>.userDao.delete(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">updateUser</span><span class="params">(String id, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">            .flatMap(u -&gt; &#123;</span><br><span class="line">                u.setName(user.getName());</span><br><span class="line">                u.setAge(user.getAge());</span><br><span class="line">                u.setDescription(user.getDescription());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.userDao.save(u);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>大致上和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>中的<code>UserService</code>差不多，不同的是返回值类型为Flux或者Mono，即它们是响应式非阻塞的方法。</p><p>编写RESTful<code>UserController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以数组的形式一次性返回所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以 Server sent events形式多次返回数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/stream"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsersStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存在返回 200，不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(<span class="meta">@PathVariable</span> String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.deleteUser(id)</span><br><span class="line">                .then(Mono.just(<span class="keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.OK)))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存在返回修改后的 User</span></span><br><span class="line"><span class="comment">     * 不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; updateUser(<span class="meta">@PathVariable</span> String id, User user) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateUser(id, user)</span><br><span class="line">                .map(u -&gt; <span class="keyword">new</span> ResponseEntity&lt;&gt;(u, HttpStatus.OK))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户 id查找</span></span><br><span class="line"><span class="comment">     * 存在返回，不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(<span class="meta">@PathVariable</span> String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id)</span><br><span class="line">                .map(user -&gt; <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, HttpStatus.OK))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于返回值为<code>Flux&lt;T&gt;</code>类型的方法，推荐定义两个一样的方法，一个以普通形式返回，一个以Server Sent Event的形式返回。对于修改和删除，如果需要修改和删除的用户不存在，我们返回404。</p><p>对于Flux和Mono的操作，在<a href="/Spring-Boot-2-0-WebFlux.html]"> Spring Boot 2.0 WebFlux编程 </a>一节中已经介绍过了，这里就不再赘述了。</p><h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><p>在<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>一节中，我们通过<code>MongoTemplate</code>实现了排序与分页。与<code>MongoTemplate</code>对于的响应式的对象为<code>ReactiveMongoTemplate</code>，所以我们照葫芦画瓢，仿照<code>MongoTemplate</code>的写法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询，只返回分页后的数据，count值需要通过 getUserByConditionCount</span></span><br><span class="line"><span class="comment"> * 方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    Query query = getQuery(user);</span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"age"</span>);</span><br><span class="line">    Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template.find(query.with(pageable), User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 count，配合 getUserByCondition使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Long&gt; <span class="title">getUserByConditionCount</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Query query = getQuery(user);</span><br><span class="line">    <span class="keyword">return</span> template.count(query, User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Query <span class="title">getQuery</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> Query();</span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getName())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"name"</span>).is(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getDescription())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"description"</span>).regex(user.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line">    <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以拆分是因为没找到与<code>PageableExecutionUtils</code>类的<code>getPage</code>方法类似的方法，如果是响应式的话，返回值类型应该是<code>Mono&lt;Page&lt;User&gt;&gt;</code>，不懂大家有没别的更好的实现方法？</p><p>源码和PostMan测试样例链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/58.Spring-Boot-WebFlux-crud" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/58.Spring-Boot-WebFlux-crud</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在&lt;a href=&quot;/Spring-Boot-2-0-WebFlux.html]&quot;&gt; Spring Boot 2.0 WebFlux编程 &lt;/a&gt;一节我们大致了解了WebFlux的用法，这节我们将结合Mongo DB在WebFlux的架构下实现增删改查样例。和&lt;a href=&quot;/Spring-Boot-Mongo-DB-CRUD.html&quot;&gt; Spring Boot整合Mongo DB &lt;/a&gt;不同的是，我们使用的是Reactive Mongo DB依赖，所有增删改查方法返回值类型为Flux或者Mono。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="MongoDB" scheme="http://mrbird.cc/tags/MongoDB/"/>
    
      <category term="WebFlux" scheme="http://mrbird.cc/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Consul服务治理</title>
    <link href="http://mrbird.cc/Spring-Cloud-Consul.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Consul.html</id>
    <published>2018-11-29T08:00:31.000Z</published>
    <updated>2019-07-12T13:02:30.531Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --><p>Consul是一款由<a href="https://www.hashicorp.com/" target="_blank" rel="noopener">HashiCorp</a>公司开源的，用于服务治理的软件，<a href="https://spring.io/projects/spring-cloud-consul" target="_blank" rel="noopener">Spring Cloud Consul</a>对其进行了封装。Consul具有如下特点:</p><ol><li><p>服务注册 - 自动注册和取消注册服务实例的网络位置</p></li><li><p>运行状况检查 - 检测服务实例何时启动并运行</p></li><li><p>分布式配置 - 确保所有服务实例使用相同的配置</p></li></ol><a id="more"></a><p>Consul agent有两种运行模式：Server和Client。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上 的应用服务无关。 以Server模式运行的Consul agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server mode的Agent，Client节点不限。</p><h2 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h2><p>Consul下载地址：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a>，本文选择Linux 64bit 版本进行演示。</p><p>下载后解压，然后在解压目录下运行<code>./consul</code>命令：</p><p><img src="img/QQ截图20190328094517.png" alt="QQ截图20190328094517.png"></p><p>可以看到Consul所包含的命令，使用<code>consul [命令] --help</code>可以查看某个命令的具体用法。</p><p>执行下面这条命令来启动一个Consul agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./consul agent -dev -client 192.168.140.215</span><br></pre></td></tr></table></figure><p></p><p><code>-dev</code>表示创建一个开发环境下的server节点，在该模式下不会有任何持久化操作，即不会有任何数据写入到磁盘，所以这个模式适合用于开发过程，而不适用于生产环境。<code>-client 192.168.140.215</code>表示运行客户端使用ip地址<code>192.168.140.215</code>（本文Linux环境IP地址）去访问。</p><p>启动后，默认的端口号为8500，访问<a href="http://192.168.140.215:8500" target="_blank" rel="noopener">http://192.168.140.215:8500</a></p><p><img src="img/QQ截图20190328100116.png" alt="QQ截图20190328100116.png"></p><p>当前就一个consul服务。接下来我们开始创建服务提供者和服务消费者。</p><h2 id="Server-Provider"><a href="#Server-Provider" class="headerlink" title="Server-Provider"></a>Server-Provider</h2><p>创建一个Spring Boot项目，版本为2.0.2.RELEASE，<code>artifactId</code>为server-provider，Spring Cloud版本为Finchley.RELEASE：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在配置文件里添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-provider</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.215</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        health-check-path:</span> <span class="string">/check</span></span><br></pre></td></tr></table></figure><p></p><p><code>spring.cloud.consul.host</code>和<code>spring.cloud.consul.port</code>配置了consul的ip和端口；<code>spring.cloud.consul.discovery.service-name</code>配置了该服务在consul里注册的服务名称；<code>spring.cloud.consul.discovery.register-health-check</code>用于开启健康检查，<code>spring.cloud.consul.discovery.health-check-interval</code>配置了健康检查的周期为10秒，<code>spring.cloud.consul.discovery.health-check-path</code>配置了健康检查路径。</p><p>接着新建TestController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"check"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"health check"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello from server provider"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>check</code>方法用于监控检查，TestController还提供了一个<code>hello</code>方法，以供后续服务消费者调用。</p><p><code>spring.cloud.consul.discovery.health-check-path</code>的默认值为<code>/actuator/health</code>，如果采用该默认值的话，还需要导入<code>spring-boot-starter-actuator</code>依赖。</p><p>最后，要开启服务注册与发行，需要在Spring Boot入口类上添加<code>@EnableDiscoveryClient</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServerProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>准备完毕后，打包项目，然后启动两个实例，端口号分别为9000和9001，启动后，再次访问consul管理界面：</p><p><img src="img/QQ截图20190328104441.png" alt="QQ截图20190328104441.png"></p><p><img src="img/QQ截图20190328104520.png" alt="QQ截图20190328104520.png"></p><p>服务提供者注册成功，接下来开始搭建服务消费者。</p><h2 id="Server-Consumer"><a href="#Server-Consumer" class="headerlink" title="Server-Consumer"></a>Server-Consumer</h2><p>创建一个Spring Boot项目，版本为2.0.2.RELEASE，artifactId为server-provider，Spring Cloud版本为Finchley.RELEASE：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>引入<code>spring-boot-starter-actuator</code>用于默认的健康检查。</p><p>配置application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-consumer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.215</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>同样的，需要开启服务注册与发现需要在入口类上添加<code>@EnableDiscoveryClient</code>注解。</p><p>接着创建TestController来消费Server-Provider提供的<code>hello</code>服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger loggr = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ID = <span class="string">"server-provider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"uri"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;URI&gt; <span class="title">getServerUris</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient.getInstances(SERVER_ID)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(ServiceInstance::getUri).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceInstance instance = loadBalancerClient.choose(SERVER_ID);</span><br><span class="line">        String url = instance.getUri().toString() + <span class="string">"/hello"</span>;</span><br><span class="line">        loggr.info(<span class="string">"remote server url：&#123;&#125;"</span>, url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>SERVER_ID</strong>的值为服务提供者在consul注册中心的实例名称，即<code>server-provider</code>。通过<code>DiscoveryClient</code>我们可以获取到所有名称为<code>server-provider</code>的服务实例信息。通过<code>LoadBalancerClient</code>我们可以实现负载均衡地去获取服务实例，并通过<code>RestTemplate</code>去调用服务。</p><p>打包部署项目，然后查看consul控制台：</p><p><img src="img/QQ截图20190328110004.png" alt="QQ截图20190328110004.png"></p><p>访问：<a href="http://192.168.140.215:9002/uri" target="_blank" rel="noopener">http://192.168.140.215:9002/uri</a>：</p><p><img src="img/QQ截图20190328110116.png" alt="QQ截图20190328110116.png"></p><p>可以看到我们成功获取到了服务名称为<code>server-provider</code>的两个具体实例。</p><p>多次调用<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328110243.png" alt="QQ截图20190328110243.png"></p><p>控制台输出如下：</p><p><img src="img/QQ截图20190328110406.png" alt="QQ截图20190328110406.png"></p><p>服务调用是均衡的。</p><p>除此之外，consul内置了Ribbon，所以我们还可以通过<code>@LoadBalanced</code>标注的<code>RestTemplate</code>来实现负载均衡服务调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ID = <span class="string">"server-provider"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">"http://"</span> + SERVER_ID + <span class="string">"/hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>效果是一样的。</p><h2 id="consul集群"><a href="#consul集群" class="headerlink" title="consul集群"></a>consul集群</h2><p>上面我们只是以<code>-dev</code>模式开启了一个单节点consul agent，生产环境下需要搭建consul集群来确保高可用。</p><p>搭建consul集群时常用的命令有:</p><table><thead><tr><th>命令</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>agent</td><td>运行一个consul agent</td><td>consul agent -dev</td></tr><tr><td>join</td><td>将agent加入到consul集群</td><td>consul join IP</td></tr><tr><td>members</td><td>列出consul cluster集群中的members</td><td>consul members</td></tr><tr><td>leave</td><td>将节点移除所在集群</td><td>consul leave</td></tr></tbody></table><p>准备了三台Linux服务器，配置如下：</p><table><tbody><tr><th width="27px"><p>序号</p></th><th><p>节点ip</p></th><th><p>节点名称</p></th><th><p>角色</p></th></tr><tr><td><p>1</p></td><td><p>192.168.140.215</p></td><td><p>consul-server-215</p></td><td><p>server</p></td></tr><tr><td><p>2</p></td><td><p>192.168.140.213</p></td><td><p>consul-server-213</p></td><td><p>server</p></td></tr><tr><td><p>3</p></td><td><p>192.168.140.216</p></td><td><p>consul-server-216</p></td><td><p>server &amp; web ui</p></td></tr></tbody></table><p>在这三台服务器上下载并解压consul，然后在解压的根目录上创建一个data目录。</p><p>由于我们之前已经在215上启动了consul，所以先执行<code>killall consul</code>来杀掉进程，然后执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.215 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-215 &amp;</span><br></pre></td></tr></table></figure><p></p><p>解释一下上面这条命令的含义:</p><ul><li><p><code>-server</code>表示以服务的形式启动agent</p></li><li><p><code>-bind</code>表示绑定到当前Linux的ip（有些服务器会绑定多块网卡，可以通过bind参数强制指定绑定的ip）</p></li><li><p><code>-client</code>指定客户端访问的ip（consul有丰富的api接口，这里的客户端指浏览器或调用方），0.0.0.0表示不限客户端ip</p></li><li><p><code>-bootstrap-expect=3</code>表示server集群最低节点数为3，低于这个值将工作不正常(注：类似zookeeper一样，通常集群数为奇数，方便选举，consul采用的是raft算法)</p></li><li><p><code>-data-dir</code>表示指定数据的存放目录（该目录必须存在）</p></li><li><p><code>-node</code>表示节点的名称</p></li></ul><p>接着在213服务器上执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.213 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-213 &amp;</span><br></pre></td></tr></table></figure><p></p><p>最后在216上执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.216 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-216 -ui &amp;</span><br></pre></td></tr></table></figure><p></p><p>和前两条命令相比，这条命令多了<code>-ui</code>选项，表示开启管理界面UI。</p><p>然后分别在213和215下执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./consul join 192.168.140.216</span><br></pre></td></tr></table></figure><p></p><p>这样213和215成功加入到了216构成了一个三节点集群，运行<code>./consul members</code>查看：</p><p><img src="img/QQ截图20190328143323.png" alt="QQ截图20190328143323.png"></p><p>访问<a href="http://192.168.140.216:8500" target="_blank" rel="noopener">http://192.168.140.216:8500</a>：</p><p><img src="img/QQ截图20190328143504.png" alt="QQ截图20190328143504.png"></p><p>访问<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328143922.png" alt="QQ截图20190328143922.png"></p><p>这时候在215执行<code>killall consul</code>命令，杀死consul服务，然后在216上执行<code>./consul members</code>：</p><p><img src="img/QQ截图20190328143837.png" alt="QQ截图20190328143837.png"></p><p><img src="img/QQ截图20190328144326.png" alt="QQ截图20190328144326.png"></p><p>可以看到215节点已经挂了，再次访问<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328143922.png" alt="QQ截图20190328143922.png"></p><p>服务依旧获取成功。</p><p>可见，虽然我们在application.yml中配置consul的地址是192.168.140.215:8500，但由于我们构建的是consul集群，所以微服务启动时会获取到整个集群信息，即使215这个节点挂了，微服务可以从别的consul节点上获取注册的服务信息。</p><p>参考文档：</p><ol><li><p><a href="https://learn.hashicorp.com/consul/getting-started/install.html" target="_blank" rel="noopener">https://learn.hashicorp.com/consul/getting-started/install.html</a></p></li><li><p><a href="https://cloud.spring.io/spring-cloud-consul/spring-cloud-consul.html#spring-cloud-consul-hystrix" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-consul/spring-cloud-consul.html#spring-cloud-consul-hystrix</a></p></li></ol><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/55.Spring-Cloud-Consul" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/55.Spring-Cloud-Consul</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Consul是一款由&lt;a href=&quot;https://www.hashicorp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HashiCorp&lt;/a&gt;公司开源的，用于服务治理的软件，&lt;a href=&quot;https://spring.io/projects/spring-cloud-consul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Consul&lt;/a&gt;对其进行了封装。Consul具有如下特点:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;服务注册 - 自动注册和取消注册服务实例的网络位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行状况检查 - 检测服务实例何时启动并运行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式配置 - 确保所有服务实例使用相同的配置&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Consul" scheme="http://mrbird.cc/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Kafka</title>
    <link href="http://mrbird.cc/Spring-Boot-Kafka.html"/>
    <id>http://mrbird.cc/Spring-Boot-Kafka.html</id>
    <published>2018-11-21T08:26:17.000Z</published>
    <updated>2019-07-12T13:02:30.520Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --><p>Kafka是一个分布式的、可分区的、可复制的消息系统，下面是Kafka的几个基本术语：</p><ol><li><p>Kafka将消息以<strong>topic</strong>为单位进行归纳；</p></li><li><p>将向Kafka topic发布消息的程序成为<strong>producers</strong>；</p></li><li><p>将预订topics并消费消息的程序成为<strong>consumer</strong>；</p></li><li><p>Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个<strong>broker</strong>。</p></li></ol><a id="more"></a><p>producers通过网络将消息发送到Kafka集群，集群向消费者提供消息，如下图所示：</p><p><img src="img/140721072031172.png" alt="140721072031172.png"></p><p>创建一个topic时，可以指定<strong>partitions</strong>（分区）数目，partitions数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到producers发送的消息之后，会根据均衡策略将消息存储到不同的partitions中：</p><p><img src="img/log_anatomy.png" alt="log_anatomy.png"></p><p>在每个partitions中，消息以顺序存储，最晚接收的的消息会最后被消费。</p><p>producers在向kafka集群发送消息的时候，可以通过指定partitions来发送到指定的partitions中。也可以通过指定均衡策略来将消息发送到不同的partitions中。如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的partitions中。</p><p>在consumer消费消息时，kafka使用offset来记录当前消费的位置：</p><p><img src="img/log_consumer.png" style="width:25rem"></p><p>在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。</p><p>对于一个group而言，consumer的数量不应该多于partitions的数量，因为在一个group中，每个partitions至多只能绑定到一个consumer上，即一个consumer可以消费多个partitions，一个partitions只能给一个consumer消费。因此，若一个group中的consumer数量大于partitions数量的话，多余的consumer将不会收到任何消息。</p><p><img src="img/consumer-groups.png" style="width:25rem"></p><h2 id="Kafka安装使用"><a href="#Kafka安装使用" class="headerlink" title="Kafka安装使用"></a>Kafka安装使用</h2><p>这里演示在Windows下Kafka安装与使用。Kafka下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a>，选择二进制文件下载（Binary downloads），然后解压即可。</p><p>Kafka的配置文件位于config目录下，因为Kafka集成了Zookeeper（Kafka存储消息的地方），所以config目录下除了有Kafka的配置文件server.properties外，还可以看到一个Zookeeper配置文件zookeeper.properties：</p><p><img src="img/QQ截图20190326103520.png" alt="QQ截图20190326103520.png"></p><p>打开server.properties，将<code>broker.id</code>的值修改为1，每个broker的id都必须设置为Integer类型，且不能重复。Zookeeper的配置保持默认即可。</p><p>接下来开始使用Kafka。</p><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><p>在Windows下执行下面这些命令可能会出现<span style="color:red">找不到或无法加载主类</span>的问题，解决方案可参考：<a href="https://blog.csdn.net/cx2932350/article/details/78870135" target="_blank" rel="noopener">https://blog.csdn.net/cx2932350/article/details/78870135</a>。</p><p>在Kafka根目录下使用cmd执行下面这条命令，启动ZK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure><p></p><p>在Linux下，可以使用后台进程的方式启动ZK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><p></p><h3 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h3><p>执行下面这条命令启动Kafka：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure><p></p><p>Linux对应命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><p></p><p>当看到命令行打印如下信息，说明启动完毕:</p><p><img src="img/QQ截图20190326110506.png" alt="QQ截图20190326110506.png"></p><h3 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h3><p>执行下面这条命令创建一个Topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>这条命令的意思是，创建一个Topic到ZK（指定ZK的地址），副本个数为1，分区数为1，Topic的名称为test。</p><p>Linux对应的命令为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>创建好后我们可以查看Kafka里的Topic列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190326111559.png" alt="QQ截图20190326111559.png"></p><p>可看到目前只包含一个我们刚创建的test Topic。</p><p>Linux对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p></p><p>查看test Topic的具体信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190326111928.png" alt="QQ截图20190326111928.png"></p><p>Linux对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><h3 id="生产消息和消费消息"><a href="#生产消息和消费消息" class="headerlink" title="生产消息和消费消息"></a>生产消息和消费消息</h3><p><strong>启动Producers</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>9092为生产者的默认端口号。这里启动了生产者，准备往test Topic里发送数据。</p><p>Linux下对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p><strong>启动Consumers</strong></p><p>接着启动一个消费者用于消费生产者生产的数据，新建一个cmd窗口，输入下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><p></p><p><code>from-beginning</code>表示从头开始读取数据。</p><p>Linux下对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><p></p><p>启动好生产者和消费者后我们在生产者里生产几条数据:</p><p><img src="img/QQ截图20190326113911.png" alt="QQ截图20190326113911.png"></p><p>消费者成功接收到数据：</p><p><img src="img/QQ截图20190326113950.png" alt="QQ截图20190326113950.png"></p><h2 id="Spring-Boot整合Kafaka"><a href="#Spring-Boot整合Kafaka" class="headerlink" title="Spring Boot整合Kafaka"></a>Spring Boot整合Kafaka</h2><p>上面简单介绍了Kafka的使用，下面我们开始在Spring Boot里使用Kafka。</p><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>新建一个Java配置类<code>KafkaProducerConfig</code>，用于配置生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="title">producerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; configProps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(configProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaTemplate&lt;String, String&gt; <span class="title">kafkaTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们配置了一个<code>producerFactory</code>，方法里配置了Kafka Producer实例的策略。<code>bootstrapServers</code>为Kafka生产者的地址，我们在配置文件application.yml里配置它：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    bootstrap-servers:</span> <span class="attr">localhost:9092</span></span><br></pre></td></tr></table></figure><p></p><p><code>ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG</code>和<code>ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG</code>指定了key，value序列化策略，这里指定为Kafka提供的<code>StringSerializer</code>，因为我们暂时只发送简单的String类型的消息。</p><p>接着我们使用<code>producerFactory</code>配置了<code>kafkaTemplate</code>，其包含了发送消息的便捷方法，后面我们就用这个对象来发送消息。</p><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>配置好生产者，我们就可以开始发布消息了。</p><p>新建一个<code>SendMessageController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们注入了<code>kafkaTemplate</code>对象，key-value都为String类型，并通过它的<code>send</code>方法来发送消息。其中<code>test</code>为Topic的名称，上面我们已经使用命令创建过这个Topic了。</p><p><code>send</code>方法是一个异步方法，我们可以通过回调的方式来确定消息是否发送成功，我们改造<code>SendMessageController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, message);</span><br><span class="line">        future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;String, String&gt; result)</span> </span>&#123;</span><br><span class="line">                logger.info(<span class="string">"成功发送消息：&#123;&#125;，offset=[&#123;&#125;]"</span>, message, result.getRecordMetadata().offset());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"消息：&#123;&#125; 发送失败，原因：&#123;&#125;"</span>, message, ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>消息发送成功后，会回调<code>onSuccess</code>方法，发送失败后回调<code>onFailure</code>方法。</p><h3 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>接着我们来配置消费者，新建一个Java配置类<code>KafkaConsumerConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableKafka</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.group-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.auto-offset-reset&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String autoOffsetReset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="title">consumerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.GROUP_ID_CONFIG,</span><br><span class="line">                consumerGroupId);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,</span><br><span class="line">                autoOffsetReset);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory</span><br><span class="line">                = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>consumerGroupId</code>和<code>autoOffsetReset</code>需要在application.yml里配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    consumer:</span></span><br><span class="line"><span class="attr">      group-id:</span> <span class="string">test-consumer</span></span><br><span class="line"><span class="attr">      auto-offset-reset:</span> <span class="string">latest</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>group-id</code>将消费者进行分组（你也可以不进行分组），组名为<code>test-consumer</code>，并指定了消息读取策略，包含四个可选值：</p><p><img src="img/QQ截图20190326154735.png" alt="QQ截图20190326154735.png"></p><ul><li><p>earliest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</p></li><li><p>latest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</p></li><li><p>none:topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</p></li><li><p>exception:直接抛出异常</p></li></ul><p>在<code>KafkaConsumerConfig</code>中我们配置了<code>ConsumerFactory</code>和<code>KafkaListenerContainerFactory</code>。当这两个Bean成功注册到Spring IOC容器中后，我们便可以使用<code>@KafkaListener</code>注解来监听消息了。</p><p>配置类上需要<code>@EnableKafka</code>注释才能在Spring托管Bean上检测<code>@KafkaListener</code>注解。</p><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>配置好消费者，我们就可以开始消费消息了，新建<code>KafkaMessageListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收消息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们通过<code>@KafkaListener</code>注解来监听名称为test的Topic，消费者分组的组名为<code>test-consumer</code>。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>启动Spring Boot项目，启动过程中，控制台会输出Kafka的配置，启动好后，访问<a href="http://localhost:8080/send/hello,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/hello,mrbird</a>，控制台输出如下：</p><p><img src="img/QQ截图20190326155948.png" alt="QQ截图20190326155948.png"></p><h3 id="KafkaListener详解"><a href="#KafkaListener详解" class="headerlink" title="@KafkaListener详解"></a>@KafkaListener详解</h3><p><code>@KafkaListener</code>除了可以指定Topic名称和分组id外，我们还可以同时监听来自多个Topic的消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"topic1, topic2"</span>)</span><br></pre></td></tr></table></figure><p></p><p>我们还可以通过<code>@Header</code>注解来获取当前消息来自哪个分区（partitions）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(@Payload String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @Header(KafkaHeaders.RECEIVED_PARTITION_ID)</span> <span class="keyword">int</span> partition) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;，partition：&#123;&#125;"</span>, message, partition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，再次访问<a href="http://localhost:8080/send/hello,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/hello,mrbird</a>，控制台输出如下：</p><p><img src="img/QQ图片20190326162014.png" alt="QQ图片20190326162014.png"></p><p>因为我们没有进行分区，所以test Topic只有一个区，下标为0。</p><p>我们可以通过<code>@KafkaListener</code>来指定只接收来自特定分区的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"test-consumer"</span>,</span><br><span class="line">        topicPartitions = <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>,</span><br><span class="line">                partitionOffsets = &#123;</span><br><span class="line">                        <span class="meta">@PartitionOffset</span>(partition = <span class="string">"0"</span>, initialOffset = <span class="string">"0"</span>)</span><br><span class="line">            &#125;))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(@Payload String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @Header(KafkaHeaders.RECEIVED_PARTITION_ID)</span> <span class="keyword">int</span> partition) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;，partition：&#123;&#125;"</span>, message, partition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果不需要指定<code>initialOffset</code>，上面代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"test-consumer"</span>, </span><br><span class="line">	topicPartitions = <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>, partitions = &#123; <span class="string">"0"</span>, <span class="string">"1"</span> &#125;))</span><br></pre></td></tr></table></figure><h3 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h3><p>我们可以为消息监听添加过滤器来过滤一些特定的信息。我们在消费者配置类<code>KafkaConsumerConfig</code>的<code>kafkaListenerContainerFactory</code>方法里配置过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory</span><br><span class="line">            = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">    factory.setConsumerFactory(consumerFactory());</span><br><span class="line">    <span class="comment">// ------- 过滤配置 --------</span></span><br><span class="line">    factory.setRecordFilterStrategy(</span><br><span class="line">            r -&gt; r.value().contains(<span class="string">"fuck"</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>setRecordFilterStrategy</code>接收<code>RecordFilterStrategy&lt;K, V&gt;</code>，他是一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RecordFilterStrategy</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(ConsumerRecord&lt;K, V&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以我们用lambda表达式指定了上面这条规则，即如果消息内容包含<code>fuck</code>这个粗鄙之语的时候，则不接受消息。</p><p>配置好后我们重启项目，分别发送下面这两条请求：</p><ol><li><p><a href="http://localhost:8080/send/fuck,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/fuck,mrbird</a></p></li><li><p><a href="http://localhost:8080/send/love,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/love,mrbird</a></p></li></ol><p>观察控制台：</p><p><img src="img/QQ截图20190326163502.png" alt="QQ截图20190326163502.png"></p><p>可以看到，fuck,mrbird这条消息没有被接收。</p><h3 id="发送复杂的消息"><a href="#发送复杂的消息" class="headerlink" title="发送复杂的消息"></a>发送复杂的消息</h3><p>截至目前位置我们只发送了简单的字符串类型的消息，我们可以自定义消息转换器来发送复杂的消息。</p><p><strong>定义消息实体</strong></p><p>创建一个Message类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6678420965611108427L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String from, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Message&#123;"</span> +</span><br><span class="line">                <span class="string">"from='"</span> + from + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", message='"</span> + message + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>改造消息生产者配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerFactory&lt;String, Message&gt; <span class="title">producerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; configProps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                JsonSerializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(configProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaTemplate&lt;String, Message&gt; <span class="title">kafkaTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们将value序列化策略指定为了Kafka提供的<code>JsonSerializer</code>，并且kafkaTemplate返回类型为<code>KafkaTemplate&lt;String, Message&gt;</code>。</p><p><strong>发送新的消息</strong></p><p>在<code>SendMessageController</code>里发送复杂的消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate&lt;String, Message&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, <span class="keyword">new</span> Message(<span class="string">"mrbird"</span>, message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改消费者配置</strong></p><p>修改消费者配置<code>KafkaConsumerConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableKafka</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.group-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.auto-offset-reset&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String autoOffsetReset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerFactory&lt;String, Message&gt; <span class="title">consumerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.GROUP_ID_CONFIG,</span><br><span class="line">                consumerGroupId);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,</span><br><span class="line">                autoOffsetReset);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(</span><br><span class="line">                props,</span><br><span class="line">                <span class="keyword">new</span> StringDeserializer(),</span><br><span class="line">                <span class="keyword">new</span> JsonDeserializer&lt;&gt;(Message.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; factory</span><br><span class="line">                = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改消息监听</strong></p><p>修改<code>KafkaMessageListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，访问<a href="http://localhost:8080/send/hello" target="_blank" rel="noopener">http://localhost:8080/send/hello</a>，控制台输出如下：</p><p><img src="img/QQ截图20190326171125.png" alt="QQ截图20190326171125.png"></p><h3 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.kafka.admin.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.admin.fail-fast=false</span> <span class="comment"># Whether to fail fast if the broker is not available on startup.</span></span><br><span class="line"><span class="string">spring.kafka.admin.properties.*=</span> <span class="comment"># Additional admin-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden.</span></span><br><span class="line"><span class="string">spring.kafka.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-commit-interval=</span> <span class="comment"># Frequency with which the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' is set to true.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-offset-reset=</span> <span class="comment"># What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.enable-auto-commit=</span> <span class="comment"># Whether the consumer's offset is periodically committed in the background.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-max-wait=</span> <span class="comment"># Maximum amount of time the server blocks before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch-min-size".</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-min-size=</span> <span class="comment"># Minimum amount of data the server should return for a fetch request.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.group-id=</span> <span class="comment"># Unique string that identifies the consumer group to which this consumer belongs.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.heartbeat-interval=</span> <span class="comment"># Expected time between heartbeats to the consumer coordinator.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.key-deserializer=</span> <span class="comment"># Deserializer class for keys.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.max-poll-records=</span> <span class="comment"># Maximum number of records returned in a single call to poll().</span></span><br><span class="line"><span class="string">spring.kafka.consumer.properties.*=</span> <span class="comment"># Additional consumer-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.value-deserializer=</span> <span class="comment"># Deserializer class for values.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.control-flag=required</span> <span class="comment"># Control flag for login configuration.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.enabled=false</span> <span class="comment"># Whether to enable JAAS configuration.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.login-module=com.sun.security.auth.module.Krb5LoginModule</span> <span class="comment"># Login module.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.options=</span> <span class="comment"># Additional JAAS options.</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-count=</span> <span class="comment"># Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-mode=</span> <span class="comment"># Listener AckMode. See the spring-kafka documentation.</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-time=</span> <span class="comment"># Time between offset commits when ackMode is "TIME" or "COUNT_TIME".</span></span><br><span class="line"><span class="string">spring.kafka.listener.client-id=</span> <span class="comment"># Prefix for the listener's consumer client.id property.</span></span><br><span class="line"><span class="string">spring.kafka.listener.concurrency=</span> <span class="comment"># Number of threads to run in the listener containers.</span></span><br><span class="line"><span class="string">spring.kafka.listener.idle-event-interval=</span> <span class="comment"># Time between publishing idle consumer events (no data received).</span></span><br><span class="line"><span class="string">spring.kafka.listener.log-container-config=</span> <span class="comment"># Whether to log the container configuration during initialization (INFO level).</span></span><br><span class="line"><span class="string">spring.kafka.listener.monitor-interval=</span> <span class="comment"># Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="string">spring.kafka.listener.no-poll-threshold=</span> <span class="comment"># Multiplier applied to "pollTimeout" to determine if a consumer is non-responsive.</span></span><br><span class="line"><span class="string">spring.kafka.listener.poll-timeout=</span> <span class="comment"># Timeout to use when polling the consumer.</span></span><br><span class="line"><span class="string">spring.kafka.listener.type=single</span> <span class="comment"># Listener type.</span></span><br><span class="line"><span class="string">spring.kafka.producer.acks=</span> <span class="comment"># Number of acknowledgments the producer requires the leader to have received before considering a request complete.</span></span><br><span class="line"><span class="string">spring.kafka.producer.batch-size=</span> <span class="comment"># Default batch size.</span></span><br><span class="line"><span class="string">spring.kafka.producer.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers.</span></span><br><span class="line"><span class="string">spring.kafka.producer.buffer-memory=</span> <span class="comment"># Total memory size the producer can use to buffer records waiting to be sent to the server.</span></span><br><span class="line"><span class="string">spring.kafka.producer.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.producer.compression-type=</span> <span class="comment"># Compression type for all data generated by the producer.</span></span><br><span class="line"><span class="string">spring.kafka.producer.key-serializer=</span> <span class="comment"># Serializer class for keys.</span></span><br><span class="line"><span class="string">spring.kafka.producer.properties.*=</span> <span class="comment"># Additional producer-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.producer.retries=</span> <span class="comment"># When greater than zero, enables retrying of failed sends.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.producer.transaction-id-prefix=</span> <span class="comment"># When non empty, enables transaction support for producer.</span></span><br><span class="line"><span class="string">spring.kafka.producer.value-serializer=</span> <span class="comment"># Serializer class for values.</span></span><br><span class="line"><span class="string">spring.kafka.properties.*=</span> <span class="comment"># Additional properties, common to producers and consumers, used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.application-id=</span> <span class="comment"># Kafka streams application.id property; default spring.application.name.</span></span><br><span class="line"><span class="string">spring.kafka.streams.auto-startup=true</span> <span class="comment"># Whether or not to auto-start the streams factory bean.</span></span><br><span class="line"><span class="string">spring.kafka.streams.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams.</span></span><br><span class="line"><span class="string">spring.kafka.streams.cache-max-size-buffering=</span> <span class="comment"># Maximum memory size to be used for buffering across all threads.</span></span><br><span class="line"><span class="string">spring.kafka.streams.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.streams.properties.*=</span> <span class="comment"># Additional Kafka properties used to configure the streams.</span></span><br><span class="line"><span class="string">spring.kafka.streams.replication-factor=</span> <span class="comment"># The replication factor for change log topics and repartition topics created by the stream processing application.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.state-dir=</span> <span class="comment"># Directory location for the state store.</span></span><br><span class="line"><span class="string">spring.kafka.template.default-topic=</span> <span class="comment"># Default topic to which messages are sent.</span></span><br></pre></td></tr></table></figure><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/54.Spring-Boot-Kafka" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/54.Spring-Boot-Kafka</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Kafka是一个分布式的、可分区的、可复制的消息系统，下面是Kafka的几个基本术语：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Kafka将消息以&lt;strong&gt;topic&lt;/strong&gt;为单位进行归纳；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将向Kafka topic发布消息的程序成为&lt;strong&gt;producers&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将预订topics并消费消息的程序成为&lt;strong&gt;consumer&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个&lt;strong&gt;broker&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="Kafka" scheme="http://mrbird.cc/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 WebFlux编程</title>
    <link href="http://mrbird.cc/Spring-Boot-2-0-WebFlux.html"/>
    <id>http://mrbird.cc/Spring-Boot-2-0-WebFlux.html</id>
    <published>2018-11-19T07:25:54.000Z</published>
    <updated>2019-07-12T13:02:30.512Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --><p>Spring MVC Web架构是基于阻塞式Servlet API构建的。Servlet 3.1后提供了非阻塞API，Spring 5.0后基于这些API构建了一套全新的非阻塞Web框架 —— WebFlux。Spring Boot 2.0基于Spring 5.0构建，所以要在Spring Boot中使用WebFlux架构，版本必须大于2.0。</p><p>通过下面这张图了解下Spring MVC和Spring WebFlux的区别：<a id="more"></a></p><p><img src="img/diagram-boot-reactor.svg" style="width:35rem"> <a href="img/https://www.cnblogs.com/javabg/p/7976977.html">https://www.cnblogs.com/javabg/p/7976977.html</a></p><p>可以看到，Spring WebFlux是非阻塞式的，支持 Reactive Streams背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。其目前只支持非关系型数据库，如Mongo，Redis等。非阻塞式的编程模型可以提高程序的并发量，提升性能和吞吐量。</p><h2 id="异步Servlet"><a href="#异步Servlet" class="headerlink" title="异步Servlet"></a>异步Servlet</h2><p>既然WebFlux是基于异步Servelt API构建的，那么我们先来看看什么是异步Servlet。</p><p>使用IDEA创建一个传统的Java Web应用（可以参考<a href="https://www.cnblogs.com/javabg/p/7976977.html" target="_blank" rel="noopener">https://www.cnblogs.com/javabg/p/7976977.html</a>），然后创建一个<code>SyncServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/sync"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7583536145022393360L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log = Logger.getLogger(SyncServlet.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.execute(request, response);</span><br><span class="line">        log.info(<span class="string">"总耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().append(<span class="string">"hello"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>doGet</code>方法中线程阻塞2秒，然后打印hello。部署项目到Tomcat，context-path为/servlet，启动后访问<a href="http://localhost:8080/servlet/sync" target="_blank" rel="noopener">http://localhost:8080/servlet/sync</a>:</p><p><img src="img/QQ截图20190401110755.png" alt="QQ截图20190401110755.png"></p><p>传统的Servlet API是阻塞的，<code>log.info(&quot;总耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;)</code>这行代码必须等待<code>this.execute()</code>执行完毕后才开始执行。</p><p>接下来看看非阻塞Servlet API是怎么搞的。新建一个<code>AsyncServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/async"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">393375716683413545L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log = Logger.getLogger(AsyncServlet.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; execute(</span><br><span class="line">            asyncContext, </span><br><span class="line">            asyncContext.getRequest(), </span><br><span class="line">            asyncContext.getResponse())</span><br><span class="line">        );</span><br><span class="line">        log.info(<span class="string">"总耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(AsyncContext asyncContext, ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().append(<span class="string">"hello"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        asyncContext.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在类上使用<code>@WebServlet(asyncSupported = true)</code>开启异步支持，通过<code>AsyncContext asyncContext = request.startAsync();</code>获取异步上下文<code>AsyncContext</code>，<code>AsyncContext</code>的<code>complete</code>方法用于标识异步调用结束。<code>CompletableFuture</code>为Java 8提供的<code>Future</code>接口实现类，可以方便的处理异步调用。</p><p>启动项目，访问<a href="http://localhost:8080/servlet/async" target="_blank" rel="noopener">http://localhost:8080/servlet/async</a>，响应耗时也在2秒左右，但是这个过程是异步的，查看控制台日志就可以证明这点：</p><p><img src="img/QQ截图20190401113446.png" alt="QQ截图20190401113446.png"></p><p>所以，异步调用适用于那些对方法返回值没有影响的操作，比如异步记录用户操作日志等。如果方法的返回值依赖于异步调用的结果，那么方法耗时在同步和异步上是没有区别的。</p><h2 id="Mono和Flux"><a href="#Mono和Flux" class="headerlink" title="Mono和Flux"></a>Mono和Flux</h2><p>了解了异步Servlet后，我们回到WebFlux，新建一个SpringBoot程序，版本为2.1.3.RELEASE，并引入<code>spring-boot-starter-webflux</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><a href="https://github.com/reactor/reactor" target="_blank" rel="noopener">Reactor</a> 是Spring WebFlux所使用的响应式库，其提供了两个特殊的类Mono和Flux。</p><p>Mono和Flux在发布订阅模式中都属于发布者（不清楚的可以参考<a href="/Java-9-Flow-API-Learn.html">Java 9 Flow API学习</a>），查看源码会发现它们都实现了Publisher接口。</p><p>Mono表示0 ~ 1个元素的数据发布者，Flux表示 0 ~ N个元素的数据发布者。我们可以通过一个例子来了解Mono和Flux，创建<code>MonoFluxTest</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoFluxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接受到数据: "</span> + item);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"处理完了!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        String[] strs = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">        Flux.fromArray(strs).map(Integer::parseInt).subscribe(subscriber);</span><br><span class="line">        Mono.fromSupplier(() -&gt; <span class="number">1</span>).map(s -&gt; s + <span class="number">1</span>).subscribe(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先创建了一个订阅者（参考<a href="/Java-9-Flow-API-Learn.html">Java 9 Flow API学习</a>），然后分别使用<code>Flux.fromArray</code>和<code>Mono.fromSupplier</code>构造了<code>Flux</code>类型发布者和<code>Mono</code>类型发布者，并和订阅者保持订阅关系。</p><p>运行main方法，控制台输出：</p><p><img src="img/QQ截图20190401134616.png" alt="QQ截图20190401134616.png"></p><p>了解了Mono和Flux后，我们新建一个TestController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"sync"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"sync method start"</span>);</span><br><span class="line">        String result = <span class="keyword">this</span>.execute();</span><br><span class="line">        logger.info(<span class="string">"sync method end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"async/mono"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">asyncMono</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"async method start"</span>);</span><br><span class="line">        Mono&lt;String&gt; result = Mono.fromSupplier(<span class="keyword">this</span>::execute);</span><br><span class="line">        logger.info(<span class="string">"async method end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>execute</code>方法返回一个值hello，所以可以使用Mono来处理返回值，使它成为一个异步方法。<code>asyncMono</code>方法返回<code>Mono&lt;String&gt;</code>类型，也就是一个String类型的数据发布者，我们不用去手动处理订阅关系，Spring会帮我们处理，我们直接返回即可。</p><p>启动项目，可以看到WebFlux默认使用的是Netty服务器：</p><p><img src="img/QQ截图20190401135918.png" alt="QQ截图20190401135918.png"></p><p>分别访问<a href="http://localhost:8080/sync" target="_blank" rel="noopener">http://localhost:8080/sync</a>和<a href="http://localhost:8080/async/mono" target="_blank" rel="noopener">http://localhost:8080/async/mono</a>，控制台输出如下：</p><p><img src="img/QQ截图20190401140024.png" alt="QQ截图20190401140024.png"></p><p><img src="img/QQ截图20190401140239.png" alt="QQ截图20190401140239.png"></p><p>可以看到<code>asyncMono</code>方法里的<code>Mono&lt;String&gt; result = Mono.fromSupplier(this::execute)</code>是异步非阻塞的，并且<a href="http://localhost:8080/async/mono" target="_blank" rel="noopener">http://localhost:8080/async/mono</a>返回的值为字符串hello。</p><p>下面我们来看一个返回类型为<code>Flux&lt;String&gt;</code>类型的例子。</p><h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server Sent Events"></a>Server Sent Events</h2><p>返回值类型为<code>Flux</code>的时候，它是一个数据流，不是一次性数据包，服务端会不断地（假如Flux数据长度大于1）往客户端发送数据。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。这种模式称为Server-Sent Events。</p><p>在TestController新增一个<code>asyncFlux</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"async/flux"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title">asyncFlux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"async method start"</span>);</span><br><span class="line">    Flux&lt;String&gt; result = Flux.fromStream(IntStream.range(<span class="number">1</span>, <span class="number">5</span>).mapToObj(i -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"int value："</span> + i;</span><br><span class="line">    &#125;));</span><br><span class="line">    logger.info(<span class="string">"async method end"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>@GetMapping</code>必须通过<code>produces</code>指定数据类型为<code>text/event-stream</code>，重启项目，访问<a href="http://localhost:8080/async/flux" target="_blank" rel="noopener">http://localhost:8080/async/flux</a>：</p><p><img src="img/flux.gif" alt="flux.gif"></p><p>前端可以通过H5的<code>EventSource</code>来接收。</p><p>引入thymeleaf依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在resources/templates下新建flux.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test sse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">"async/flux"</span>);</span></span><br><span class="line"><span class="javascript">    es.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(evt.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (evt.data === <span class="string">"int value：4"</span>) &#123;</span></span><br><span class="line"><span class="undefined">            es.close();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>需要调用<code>es.close()</code>来关闭事件流，不然<code>EventSource</code>会在数据传输完毕会自动重连，这样就会不间断的调用<code>localhost:8080/async/flux</code>请求了。</p><p>添加一个ViewController，用来访问flux.html：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"flux"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">flux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"flux"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，访问<a href="http://localhost:8080/flux" target="_blank" rel="noopener">http://localhost:8080/flux</a>，浏览器控制台输出如下所示:</p><p><img src="img/asfasfdvvasd.gif" alt="asfasfdvvasd.gif"></p><h2 id="Mono-Flux常用方法"><a href="#Mono-Flux常用方法" class="headerlink" title="Mono,Flux常用方法"></a>Mono,Flux常用方法</h2><p>通过上面的例子，我们简单了解了Mono和Flux的用法和区别，下面我们列举一些它们的常用方法。</p><h3 id="源头操作"><a href="#源头操作" class="headerlink" title="源头操作"></a>源头操作</h3><p><strong>Flux</strong></p><p>可以通过Flux类的静态方法来生成：</p><ol><li><p><code>just()</code>：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</p></li><li><p><code>fromArray()</code>，<code>fromIterable()</code>和 <code>fromStream()</code>：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</p></li><li><p><code>empty()</code>：创建一个不包含任何元素，只发布结束消息的序列。</p></li><li><p><code>error(Throwable error)</code>：创建一个只包含错误消息的序列。</p></li><li><p><code>never()</code>：创建一个不包含任何消息通知的序列。</p></li><li><p><code>range(int start, int count)</code>：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</p></li><li><p><code>interval(Duration period)</code>和 <code>interval(Duration delay, Duration period)</code>：创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</p></li></ol><p>举些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Flux.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>).subscribe(System.out::println);</span><br><span class="line">    Flux.fromArray(<span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).subscribe(System.out::println);</span><br><span class="line">    Flux.empty().subscribe(System.out::println);</span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">4</span>).subscribe(System.out::println);</span><br><span class="line">    Flux.interval(Duration.of(<span class="number">1</span>, ChronoUnit.SECONDS)).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 线程延迟关闭，不然最后一个例子木有输出</span></span><br><span class="line">    Thread.currentThread().join(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示： <img src="img/QQ截图20190401170048.png" alt="QQ截图20190401170048.png"></p><p>上面的这些静态方法适合于简单的Flux序列生成，当序列的生成需要复杂的逻辑时，则应该使用<code>generate()</code>或<code>create()</code>方法。</p><p><strong>generate()</strong></p><p>generate()方法通过同步和逐一的方式来产生 Flux 序列。序列的产生是通过调用所提供的 SynchronousSink 对象的 next()，complete()和 error(Throwable)方法来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.generate(sink -&gt; &#123;</span><br><span class="line">    sink.next(<span class="string">"Hello"</span>);</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.generate(ArrayList::<span class="keyword">new</span>, (list, sink) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> value = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    list.add(value);</span><br><span class="line">    sink.next(value);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">10</span>) &#123;</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示:</p><p><img src="img/QQ截图20190401170950.png" alt="QQ截图20190401170950.png"></p><p>如果不调用 complete()方法，所产生的是一个无限序列。</p><p><strong>create()</strong></p><p>create()方法与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sink.next(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>Mono</strong></p><p>Mono 的创建方式与之前介绍的 Flux 比较相似。Mono 类中也包含了一些与 Flux 类中相同的静态方法。这些方法包括 just()，empty()，error()和 never()等。除了这些方法之外，Mono 还有一些独有的静态方法：</p><ol><li><p><code>fromCallable()</code>、<code>fromCompletionStage()</code>、<code>fromFuture()</code>、<code>fromRunnable(</code>)和 <code>fromSupplier()</code>：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</p></li><li><p><code>delay(Duration duration)</code>：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</p></li><li><p><code>ignoreElements(Publisher&lt;T&gt; source)</code>：创建一个 Mono 序列，忽略作为源的 Publisher 中的所有元素，只产生结束消息。</p></li><li><p><code>justOrEmpty(Optional&lt;? extends T&gt; data)</code>和 <code>justOrEmpty(T data)</code>：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</p></li></ol><p>举些例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">"are"</span>).subscribe(System.out::println);</span><br><span class="line">Mono.empty().subscribe(System.out::println);</span><br><span class="line">Mono.fromSupplier(() -&gt; <span class="string">"you"</span>).subscribe(System.out::println);</span><br><span class="line">Mono.justOrEmpty(Optional.of(<span class="string">"ok"</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出:</p><p><img src="img/QQ截图20190401173002.png" alt="QQ截图20190401173002.png"></p><p>还可以通过 create()方法来使用 MonoSink 来创建 Mono：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.create(sink -&gt; sink.success(<span class="string">"Hello"</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p><strong>filter</strong></p><p>对流中包含的元素进行过滤，只留下满足 Predicate 指定条件的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出前10偶数。</p><p><strong>take</strong></p><p>take 系列操作符用来从当前流中提取元素。提取的方式可以有很多种。</p><ol><li><p><code>take(long n)</code>：按照指定的数量来提取。</p></li><li><p><code>takeLast(long n)</code>：提取流中的最后 N 个元素。</p></li><li><p><code>takeUntil(Predicate&lt;? super T&gt; predicate)</code>：提取元素直到 Predicate 返回 true。</p></li></ol><p>4 <code>takeWhile(Predicate&lt;? super T&gt; continuePredicate)</code>： 当 Predicate 返回 true 时才进行提取。</p><p>举些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).take(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeLast(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeWhile(i -&gt; i &lt; <span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeUntil(i -&gt; i == <span class="number">10</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p><strong>reduce 和 reduceWith</strong></p><p>reduce 和 reduceWith 操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的 Mono 序列。累积操作是通过一个 BiFunction 来表示的。在操作时可以指定一个初始值。如果没有初始值，则序列的第一个元素作为初始值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).reduce((x, y) -&gt; x + y).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).reduceWith(() -&gt; <span class="number">10</span>, (x, y) -&gt; x + y).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>第一行语句对流中的元素进行相加操作，结果为 55；第二行语句同样也是进行相加操作，不过通过一个 Supplier 给出了初始值为 10，所以结果为 65。</p><p><strong>merge</strong></p><p><code>merge</code>操作符用来把多个流合并成一个 Flux 序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.merge(</span><br><span class="line">        Flux.interval(Duration.of(<span class="number">500</span>, ChronoUnit.MILLIS)).take(<span class="number">2</span>),</span><br><span class="line">        Flux.interval(Duration.of(<span class="number">500</span>, ChronoUnit.MILLIS)).take(<span class="number">2</span>)</span><br><span class="line">).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出 0 0 1 1。</p><p><strong>buffer</strong></p><p>直接看例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).buffer(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferUntil(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferWhile(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示：</p><p><img src="img/QQ截图20190402090631.png" alt="QQ截图20190402090631.png"></p><p>类似于数据流分区。</p><p><strong>zipWith</strong></p><p>将两个流的元素安装元素位置一一组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br><span class="line">    .zipWith(Flux.just(<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p><img src="img/QQ截图20190402092516.png" alt="QQ截图20190402092516.png"></p><p>没有配对上的被丢弃。</p><p>另外一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br><span class="line">    .zipWith(Flux.just(<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>), (s1, s2) -&gt; String.format(<span class="string">"%s-%s"</span>, s1, s2))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下:</p><p><img src="img/QQ截图20190402092833.png" alt="QQ截图20190402092833.png"></p><p><strong>flatMap</strong></p><p>把流中的每个元素转换成一个流，再把所有流中的元素进行合并。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">5</span>, <span class="number">10</span>).flatMap(</span><br><span class="line">            x -&gt; Flux.range(<span class="number">1</span>, x).take(x)</span><br><span class="line">    ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><h3 id="终端处理"><a href="#终端处理" class="headerlink" title="终端处理"></a>终端处理</h3><p>通过<code>subscribe()</code>方法处理正常和错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure><p></p><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure><p></p><p>出现错误时返回默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>出现错误时使用另外的流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException()))</span><br><span class="line">    .onErrorResume(e -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.just(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.just(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/57.Spring-Boot-WebFlux" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/57.Spring-Boot-WebFlux</a></p><p>参考链接:</p><ol><li><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a></p></li><li><p><a href="https://projectreactor.io/docs/core/release/reference/#flux" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#flux</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html</a></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:15 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Spring MVC Web架构是基于阻塞式Servlet API构建的。Servlet 3.1后提供了非阻塞API，Spring 5.0后基于这些API构建了一套全新的非阻塞Web框架 —— WebFlux。Spring Boot 2.0基于Spring 5.0构建，所以要在Spring Boot中使用WebFlux架构，版本必须大于2.0。&lt;/p&gt;&lt;p&gt;通过下面这张图了解下Spring MVC和Spring WebFlux的区别：
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="WebFlux" scheme="http://mrbird.cc/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Mongo DB</title>
    <link href="http://mrbird.cc/Spring-Boot-Mongo-DB-CRUD.html"/>
    <id>http://mrbird.cc/Spring-Boot-Mongo-DB-CRUD.html</id>
    <published>2018-11-15T02:41:51.000Z</published>
    <updated>2019-07-12T13:02:30.521Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --><p>这节我们将整合Spring Boot与Mongo DB实现增删改查的功能，并且实现序列递增。Mongo DB下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a>。Mongo DB的基本介绍和增删改查的用法可以参考我之前的文章：<a href="https://mrbird.cc/MongoDB-shell.html"> MongoDB shell </a>、<a href="https://mrbird.cc/MongoDB%E6%96%87%E6%A1%A3CUD.html"> MongoDB文档CUD </a>和<a href="https://mrbird.cc/MongoDB-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2.html"> MongoDB 文档查询 </a>。</p><a id="more"></a><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后可以通过Mongo Shell或者Mongo Compass工具创建一个名称为testdb的数据库，并新增user文档（文档，类似与关系型数据库里的数据表）：</p><p><img src="img/QQ截图20190402141210.png" alt="QQ截图20190402141210.png"></p><p>在配置文件application.yml里配置Mongo DB：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">      database:</span> <span class="string">testdb</span></span><br></pre></td></tr></table></figure><p></p><p>Mongo DB的默认端口为27017，使用的数据库为刚刚创建的testdb。</p><p>创建User实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Document(collection = &quot;user&quot;)</code>表明这是一个文档对象，名称为<code>user</code>，对应Mongo DB里的user表。<code>@Id</code>标注主键字段，String类型的主键值在插入的时候Mongo DB会帮我们自动生成。如果对象中的某个属性为非表字段，可以使用注解<code>@Transient</code>进行排除。</p><p>准备好这些后，我们开始编写一些简单的增删改查样例。</p><h2 id="简单增删改查"><a href="#简单增删改查" class="headerlink" title="简单增删改查"></a>简单增删改查</h2><p>创建一个UserDao接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接口继承自<code>MongoRepository</code>，泛型分别为实体对象和主键类型。通过继承<code>MongoRepository</code>，<code>UserDao</code>包含了一些增删改查的方法，如下图所示：</p><p><img src="img/QQ截图20190404094010.png" alt="QQ截图20190404094010.png"></p><p>接着编写UserService，为了方便这里不再编写接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增和修改都是 save方法，</span></span><br><span class="line"><span class="comment">     * id 存在为修改，id 不存在为新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.setId(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">                .ifPresent(user -&gt; <span class="keyword">this</span>.userDao.delete(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(String id, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">            .ifPresent(</span><br><span class="line">                u -&gt; &#123;</span><br><span class="line">                    u.setName(user.getName());</span><br><span class="line">                    u.setAge(user.getAge());</span><br><span class="line">                    u.setDescription(user.getDescription());</span><br><span class="line">                    <span class="keyword">this</span>.userDao.save(u);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面我们编写了基本的增删改查样例，新增和修改都是通过<code>save</code>方法完成的，当主键存在时则为修改，主键不存在则为新增。</p><p>最后编写一个RESTful的UserController（为了方便，没有对参数进行校验）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@PathVariable String id, User user)</span> </span>&#123;</span><br><span class="line">        userService.updateUser(id, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户 id查找</span></span><br><span class="line"><span class="comment">     * 存在返回，不存在返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，使用postman来测试接口的可用性。</p><p>测试新增用户：</p><p><img src="img/QQ截图20190404094900.png" alt="QQ截图20190402142923.png"></p><p>新增成功，查看数据库：</p><p><img src="img/QQ截图20190404094944.png" alt="QQ截图20190404094944.png"></p><p>测试查询用户：</p><p><img src="img/QQ截图20190404095026.png" alt="QQ截图20190402143028.png"></p><p>查询成功。</p><p>测试通过用ID查找用户：</p><p><img src="img/QQ截图20190404095104.png" alt="QQ截图20190402143107.png"></p><p>更新用户：</p><p><img src="img/QQ截图20190404095151.png" alt="QQ截图20190402143139.png"></p><p>查看数据库是否更新成功：</p><p><img src="img/QQ截图20190404095609.png" alt="QQ截图20190402143232.png"></p><p>更新成功。</p><p>最后测试通过用户ID删除用户：</p><p><img src="img/QQ截图20190404095646.png" alt="QQ截图20190402143320.png"></p><p>返回状态码200，删除成功。</p><p>查看数据库，删除成功：</p><p><img src="img/QQ截图20190404095710.png" alt="QQ截图20190404095710.png"></p><h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p>其实<code>UserDao</code>通过继承<code>MongoRepository</code>已经具有了JPA的特性，我们可以通过方法名来构建多查询条件的SQL。比如通过用户的年龄段来查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据年龄段来查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to   to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByAgeBetween</span><span class="params">(Integer from, Integer to)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在输入<code>findBy</code>后，IDEA会根据实体对象的属性和SQL的各种关键字自动组合提示：</p><p><img src="img/fasdfasdf.png" alt="QQ截图20190404101118.png"></p><p>比如再在创建一个通过年龄段，用户名和描述（模糊查询）查询用户的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过年龄段，用户名，描述（模糊查询）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from        from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to          to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name        name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> description description</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;User&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByAgeBetweenAndNameEqualsAndDescriptionIsLike</span><span class="params">(Integer from, Integer to, String name, String description)</span></span>;</span><br></pre></td></tr></table></figure><p>方法参数个数需要和方法名中所需要的参数个数对应上。</p><h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><p>排序和分页需要使用<code>MongoTemplate</code>对象来完成，在<code>UserService</code>里新增一个<code>getUserByCondition</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> Query();</span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getName())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"name"</span>).is(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getDescription())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"description"</span>).regex(user.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line"></span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"age"</span>);</span><br><span class="line">    Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = template.find(query.with(pageable), User.class);</span><br><span class="line">    <span class="keyword">return</span> PageableExecutionUtils.getPage(users, pageable, () -&gt; template.count(query, User.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>size</code>表示每页显示的条数，<code>page</code>表示当前页码数，0表示第一页。上面的方法通过<code>name</code>和<code>description</code>（模糊查询）来查询用户分页信息，并且查询结果使用<code>age</code>字段降序排序。方法返回<code>Page</code>对象。</p><p>在<code>UserController</code>里添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/condition"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getUserByCondition(size, page, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，我们往数据库里多加几条数据：</p><p><img src="img/QQ截图20190404102609.png" alt="QQ截图20190404102609.png"></p><p>获取第1页数据，每页显示10条：</p><p><img src="img/QQ截图20190404102736.png" alt="QQ截图20190404102736.png"></p><p>返回数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"content"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56ae2f08f0b6048fd470d"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"jane"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">26</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"web developer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56ad1f08f0b6048fd470c"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"scott"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"ui designer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56afaf08f0b6048fd470e"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"mike"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">21</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"python developer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56b38f08f0b6048fd470f"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"mrbird"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"java noob"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pageable"</span>: &#123;</span><br><span class="line">        <span class="attr">"sort"</span>: &#123;</span><br><span class="line">            <span class="attr">"sorted"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"unsorted"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"offset"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"pageSize"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"pageNumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"unpaged"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"paged"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"last"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"totalPages"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"totalElements"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"number"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"sort"</span>: &#123;</span><br><span class="line">        <span class="attr">"sorted"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"unsorted"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"numberOfElements"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"first"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>剩下可以自己测试。</p><p>postman测试样例及源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/56.Spring-Boot-MongoDB-crud" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/56.Spring-Boot-MongoDB-crud</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Sep 11 2019 16:16:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这节我们将整合Spring Boot与Mongo DB实现增删改查的功能，并且实现序列递增。Mongo DB下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center/community&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/download-center/community&lt;/a&gt;。Mongo DB的基本介绍和增删改查的用法可以参考我之前的文章：&lt;a href=&quot;https://mrbird.cc/MongoDB-shell.html&quot;&gt; MongoDB shell &lt;/a&gt;、&lt;a href=&quot;https://mrbird.cc/MongoDB%E6%96%87%E6%A1%A3CUD.html&quot;&gt; MongoDB文档CUD &lt;/a&gt;和&lt;a href=&quot;https://mrbird.cc/MongoDB-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2.html&quot;&gt; MongoDB 文档查询 &lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="MongoDB" scheme="http://mrbird.cc/tags/MongoDB/"/>
    
  </entry>
  
</feed>
